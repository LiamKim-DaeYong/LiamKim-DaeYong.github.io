---
title: "[스프링 핵심원리-기본편] 3. 좋은 객체 지향 설계의 5가지 원칙(SOLID)"
search: true
categories: [스프링, 스프링 핵심 원리-기본편]
tags: [Srping]
toc: true
---



해당 글은 김영한님의 [스프링 핵심 원리 -기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard) 강의를 수강하며 학습한 내용을 정리한 포스팅입니다.



## SOLID

[이전 포스팅]({{site.url}}/posts/spring-basics-02)에서 **좋은 객체 지향 프로그래밍**이란 무엇인지를 알아보았다. 이번 포스팅에서는 좋은 객체 지향 설계를 위한 방법론을 알아보도록 하자.

클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리 하였다


- SRP: 단일 책임 원칙(Single Responsibility Principle)

- OCP: 개방-폐쇄 원칙(Open/Closed Principle)

- LSP: 리스코프 치환 원칙(Liskov Substitution Principle)

- ISP: 인터페이스 분리 원칙(Interface Segregation Principle)

- DIP: 의존관계 역전 원칙(Dependency Inversion Principle)

  <br>

### SRP 단일 책임 원칙 (Single Responsibility Principle)


- 단일 책임원칙은 하나의 클래스는 하나의 책임만 가져야 한다는 원칙으로 중요한 기준은 변경이다.
- 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이라 볼 수 있다. (새로운 로직이 추가 되었을 때 기존코드는 한줄만 수정하면 된다 혹은 수정을 하지 않아도 된다)



### OCP 개방-폐쇄 원칙 (Open/Closed Principle)


- 소프트웨어 요소는 **확장에는 열려** 있으나 **변경에는 닫혀** 있어야 한다는 원칙으로 이는 **다형성을 활용**하여 구현할 수 있다.

- 인터페이스를 구현하여 **새로운 기능을 확장**



  ```java
  public class MemberService {
  	// private MemberRepository memberRepository = new MemoryMemberRepository();
  	private MemberRepository memberRepository = new JdbcMemberRepository();
  }
  ```

- `MemberRepository` 인터페이스를 구현하여 `JdbcMemberRepository`를 만들었다. 이를 통해 기능을 **확장**할 수 있다. 하지만 **한가지 문제점**이 남아있다.

  <br>

  **OCP 개방-폐쇄 원칙 문제점**


  - 위 코드의 문제점은 `MemberService(클라이언트)`가 **구현 클래스를 직접 선택 하는것** 이다.

  - 한마디로 구현 객체를 변경하려면(확장하려면) **클라이언트 코드를 변경해야 한다.**

    분명 다형성을 사용했지만 클라이언트 코드를 변경해야 한다.

    이 문제를 해결하기 위해서는 객체를 생성하고, 연관관계를 맺어주는 **별도의 조립, 설정자가 필요**하다.



### LSP 리스코프 치환원칙 (Liskov Substitution Principle)

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

- 한마디로 다형성에서 **하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것**이다. 이는 다형성을 지원하기 위한 원칙으로 인터페이스를 구현한 구현체를 믿고 사용하려면, 이 원칙이 필요하다.

  <br>

  이는 단순히 컴파일에 성공하는 것을 넘어서는 이야기다.

  예를 들어 자동차 인터페이스의 엑셀이 전진하는 기능이라고 가정한다. 이를 후진 기능으로 구현했다면 이는 **LSP를 위반**한 것이다.

  인터페이스 규약을 지키기 위해서는 느리더라도 앞으로 전진해야한다.



### ISP 인터페이스 분리 원칙 (Interface Segregation Principle)

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.

  예를 들면 **자동차 인터페이스** 하나 보다는 **운전 인터페이스**, **정비 인터페이스**로 분리하는게 더 좋다는 의미

  `자동차 인터페이스` -> `운전 인터페이스`와 `정비 인터페이스`로 분리

  `사용자(클라이언트)` -> `운전자`와 `정비사`로 분리

  이렇게 분리할 경우 `정비 인터페이스` 자체가 변해도(정비공정이 달라지는 경우 혹은 다른 변경) `운전자`에게 영향을 주지 않음

- 인터페이스가 명확해지고, 대체 가능성이 높아진다.



### DIP 의존관계 역전 원칙(Dependency Inversion Principle)

- 프로그래머는 **추상화에 의존해야지, 구체화에 의존하면 안된다.** (스프링의 `의존관계 주입(DI)`은 이 원칙을 따르는 방법 중 하나)

  쉽게 이야기하면 **구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻**

  앞에서 이야기한 **역할에 의존해야 한다는 것**과 같은 의미다. 객체 세상도 `클라이언트`가 `인터페이스`에 의존해야 유연하게 구현체를 변경할 수 있다. 만약 구현체에 의존하고 있다면 변경이 아주 어려워진다.

  <br>

  앞서 언급한 **OCP 개방-폐쇄 원칙 문제점**에 대해 다시 이야기해보자.

  `MemberService`는 `인터페이스에 의존`하지만, 동시에 `구현 클래스도 의존`하고 있다.

  ```java
  public class MemberService {
      //             [인터페이스 의존]                     [구현클래스 의존]
  	private MemberRepository memberRepository = new MemoryMemberRepository();
  }
  ```

  위 코드는 **OCP** 뿐만 아니라 **DIP**도 위반하고 있다.



### 정리

- 객체 지향의 핵심은 다형성
- 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
- 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- **다형성 만으로는 OCP, DIP를 지킬 수 없다**.



## 객체 지향 설계와 스프링

다시 스프링으로 돌아와 생각 해보자. 왜 스프링에서 객체 지향에 대한 이야기가 나오는가?

이유는 스프링이 아래의 기술들을 통해 **OCP와 DIP**를 가능하게 지원하기 때문이다.

- DI(Dependency Injection): 의존관계(의존성) 주입
- DI 컨테이너 제공

**스프링을 사용하면 클라이언트 코드의 변경 없이 기능을 확장할 수 있다.** (부품을 교체하듯이 개발)

<br>

`OCP`와` DIP` 원칙을 지키기 위해서는 스프링을 사용해야 된다 처럼 보일 수 있지만 사실 **순수한 자바코드로도 구현은 가능**하다. **다만 이 경우 실제 비즈니스 로직의 구현보다 OCP와 DIP원칙을 지키기 위해 구현할 코드의 양이 더 많아질 수 있다.**



## 정리

- 모든 설계에 **역할**과 **구현**을 분리하자. (자동차, 공연의 예를 떠올려보자)

- 애플리케이션 설계도 공연을 설계 하듯 배역만 만들어두고, 배우는 언제든 **유연하게 변경**할 수 있도록 만드는 것이 **좋은 객체 지향 설계**이다.

- 이상적으로는 모든 설계에 인터페이스를 부여하자

  (실무에서의 고민)

  - 하지만 인터페이스를 도입하면 추상화라는 비용이 발생한다.
  - 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩토링하여 인터페이스를 도입하는 것도 좋은 방법이다.



