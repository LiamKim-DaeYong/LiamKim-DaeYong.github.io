[ { "title": "즉시로딩과 지연로딩 그리고 프록시", "url": "/posts/jpa-14/", "categories": "JPA", "tags": "JPA, 지연로딩, 즉시로딩, 프록시", "date": "2022-08-22 00:00:00 +0900", "snippet": "회원 엔티티와 팀 엔티티회원 엔티티와 팀 엔티티가 있다고 가정해보자. 둘은 다음과 같은 관계가 있다. 회원은 하나의 팀에 소속될 수 있다. 하나의 팀은 다수의 회원을 포함하고 있다.이 경우 회원을 조회한다고 했을 때 팀 엔티티도 함께 조회하는 것이 좋을까? 아니면 회원 엔티티만을 조회하는 것이 좋을까?@Entity@Getterpublic class Member { @Id private Long memberId; private String memberName; @ManyToOne private Team team;}@Entity@Getterpublic class Team { @Id private Long teamId; private String name;}팀과 회원 엔티티를 작성하였다. 그리고 아래에서 회원과 팀 정보를 출력하는 코드를 작성할 것이다.public void printMemberAndTeam(String memberId) { Member member = em.find(Member.class, memberId) Team team = member.getTeam(); System.out.println(&quot;회원 이름 : &quot; + member.getMemberName()); System.out.println(&quot;팀 이름 : &quot; + team.getName());}코드를 살펴보면 영속성컨텍스트에서 회원을 가져온 뒤 회원을 통해 팀을 가져왔다. 이 때는 회원과 팀의 정보가 모두 필요하므로 데이터베이스에서 둘을 함께 조회해야한다. 반면에 아래와 같은 경우는 어떨까?public void printMember(String memberId) { Member member = em.find(Member.class, memberId) System.out.println(&quot;회원 이름 : &quot; + member.getMemberName());}이 경우는 회원 엔티티만을 조회하여 회원의 정보만 출력하였다. 이 경우는 팀 엔티티는 전혀 사용하지 않았다. 그러므로 팀 엔티티까지 데이터베이스에서 조회하는 것은 효율적이지 않다.이때는 팀 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는게 효율적이다.위와 같이 상황에 따라서 둘을 함께 조회할 수도 있고 아닐 수도 있다. 여기서 중요한점은 엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아니라는 점이다.JPA에는 이러한 상황에서 개발자가 연관된 엔티티의 조회 시점을 선택할 수 있도록 아래의 두가지 방법을 제공한다. 즉시로딩(EAGER) : 엔티티를 조회할 때 연관된 엔티티도 함께 조회 지연로딩(LAZY) : 연관된 엔티티를 실제 사용 시점에 조회즉시로딩(EAGER)즉시로딩은 엔티티를 조회할 때 연관된 엔티티도 함께 조회하는 것을 말한다. 위의 예제의 경우 회원을 조회할 때 팀도 함께 조회하는 것이다.@Entity@Getterpublic class Member { @Id private Long memberId; private String memberName; @ManyToOne(fetch = FetchType.EAGER) @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team;}즉시 로딩은 fetchType.EAGER를 통해 설정할 수 있다. 그리고 회원을 조회할 때 팀도 조회 해야하므로 쿼리가 2번 실행될 것 같지만, 대부분의 JPA 구현체는 즉시 로딩을 최적화 하기 위해 가능하면 조인쿼리를 사용한다.SELECT M.MEMBER_ID AS MEMBER_ID, M.TEAM_ID AS TEAM_ID, M.MEMBER_NAME AS MEMBER_NAME, T.TEAM_ID AS TEAM_ID, T.NAME AS NAMEFROM MEMBER MLEFT OUTER JOIN TEAM T ON M.TEAM_ID = T.TEAM_IDWHERE M.MEMBER_ID = &#39;member1&#39;Null 제약조건과 JPA 조인 전략쿼리 결과를 보면 내부 조인이 아닌 외부조인을 사용한 것을 알 수 있다. 일반적으로는 내부조인이 외부조인보다 성능과 최적화에서 더 유리하다.그렇지만 JPA가 외부조인을 통해 값을 가져온 이유는 현재 회원 테이블에 TEAM_ID 외래 키는 Null을 허용하고 있다.만약 팀에 소속하지 않은 회원과 팀을 내부 조인하면 팀은 물론이고 회원 데이터도 조회할 수 없으므로 JPA는 이러한 상황을 고려하여 외부조인을 사용하였다.만약 TEAM_ID 외래 키가 Null을 허용하지 않는 경우라면 팀에 소속하지 않는 회원이 없다는 것을 보장하므로 JPA는 외부조인이 아닌 내부조인을 사용하여 조회한다.@Entity@Getterpublic class Member { @Id private Long memberId; private String memberName; @ManyToOne(fetch = FetchType.EAGER) @JoinColumn(name = &quot;TEAM_ID&quot;, nullable = false) private Team team; // 또는 @ManyToOne(fetch = FetchType.EAGER, optional = false) @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team;}지연로딩(LAZY)지연로딩은 연관된 엔티티의 조회를 실제 사용 시점까지 지연 시키는 것을 말한다. 이는 FetchType.LAZY를 통해 지정할 수 있다.@Entity@Getterpublic class Member { @Id private Long memberId; private String memberName; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team;}Member member = em.find(Member.class, memberId)Team team = member.getTeam(); // 객체 그래프 탐색team.getName(); // 팀 객체 실제 사용지연로딩을 사용하면 em.find(Member.class, memberId)로 회원을 조회할 때 팀은 조회하지 않는다. 대신 team 멤버변수에 실제 팀 엔티티를 대신하여 프록시 객체를 넣어둔다.그리고 실제 팀의 데이터를 조회하는 team.getName()이 호출되었을 때 프록시 객체를 통해 데이터베이스에서 팀을 조회한다.프록시JPA는 엔티티를 직접 조회하면 조회한 엔티티를 실제 사용하든 사용하지 않든 데이터베이스를 조회하게 된다.그렇기 때문에 실제 사용시점까지 조회를 지연시키기 위해 team 멤버변수에 팀 엔티티가 아닌 가짜 객체를 넣어둘 필요성이 생긴다. 이것이 위에서 언급한 프록시이다.프록시의 특징프록시는 team을 대신하는 가짜 객체이다. 하지만 team 멤버변수에 초기화 되기 위해서는 팀 엔티티와 같은 타입을 가져야만 한다.그로인해 프록시 클래스는 실제 클래스를 상속 받아서 만들어진다. 따라서 사용자 입장에서는 이것이 진짜 객체인지 프록시 객체인지 구분하지 않고 사용할 수 있다.또한 프록시 객체는 실제 객체에 대한 참조(target)를 보관하고 있다. 그리고 프록시 객체의 메소드가 호출되면 참조를 통해 실제 객체의 메소드를 호출하게 된다.프록시 조회영속성컨텍스트를 통해 프록시를 조회할 수 있는데 이 때는 em.getReference()를 사용하면 된다. 프록시를 조회하면 JPA는 데이터베이스를 조회하지 않고 실제 엔티티 객체도 생성하지 않는다.Member member = em.find(Member.class, &quot;member1&quot;); // 엔티티 조회Member member = em.getReference(Member.class, &quot;member1&quot;); // 프록시 조회프록시 객체의 초기화프록시 객체는 team.getName()처럼 실제 사용되는 시점에 데이터베이스를 조회하여 실제 엔티티 객체를 생성한다. 그리고 이를 프록시 객체의 초기화라 한다.여기서 주의할점은 프록시 객체를 초기화 한다고 실제 엔티티로 변경되는 것은 아니다. 단지 프록시 객체가 초기화되면 프록시 객체를 통해 실제 엔티티에 접근할 수 있는 것이다.프록시의 초기화 과정 프록시 객체에 team.getName()을 호출하여 실제 데이터를 조회한다. 프록시 객체는 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 실제 엔티티 생성을 요청하는데 이것을 초기화라 한다. 영속성 컨텍스트는 데이터베이스를 조회하여 실제 엔티티 객체를 생성한다. 프록시 객체는 생성된 실제 엔티티 객체의 참조를 멤버변수에 보관한다. 프록시 객체는 실제 엔티티 객체의 getName()을 호출하여 결과를 반환한다.프록시 정리 프록시 객체는 처음 사용할 때 한번만 초기화 된다. 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 프록시 객체가 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다. 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시에 주의해서 사용해야 한다. 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없으므로 em.getReference()를 호출해도 프록시가 아닌 실제 엔티티가 반환된다. 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태의 프록시를 초기화하면 문제가 발생한다.참고 인프런 자바 ORM 표준 JPA 프로그래밍 - 기본편(김영한) 자바 ORM 표준 JPA 프로그래밍" }, { "title": "@MappedSuperclass", "url": "/posts/jpa-13/", "categories": "JPA", "tags": "JPA, 상속관계 매핑", "date": "2022-08-18 00:00:00 +0900", "snippet": "@MappedSupperclass이전 포스팅에서 상속 관계 매핑에 대해서 알아보았다. 상속관계 매핑은 부모 클래스와 자식 클래스를 모두 데이터베이스 테이블과 매핑하였는데부모 클래스는 테이블과 매핑하지 않고 부모 클래스를 상속받는 자식 클래스에게 매핑 정보만 제공할 때 사용하는 것이 @MappedSupperclass 이다.회원(Member)과 판매자(Seller)는 서로 연관이 없는 테이블이다. 하지만 둘은 id, name이라는 공통 속성을 가지고 있다.그림과 같이 우리는 상속을 통해 이를 표현해보자.@MappedSupperclasspublic abstract class BaseEntity { @Id @GeneratedValue private Long id; private String name;}@Entitypublic class Member extends BaseEntity { private String email;}@Entitypublic class Seller extends BaseEntity { private String shopName;}코드를 살펴보면 BaseEntity에 공통 속성인 id와 name을 정의하고 이를 상속 받도록 하였다.여기서 중요한점은 BaseEntity는 단순히 공통 속성을 상속하는 목적으로 사용되었기 때문에 실제 테이블과 매핑할 필요가 없다는 점이다.이때 사용하는 것이 @MappedSupperclass이고 JPA는 이 어노테이션이 붙은 클래스(부모 클래스)를 테이블과 매핑하지 않는다.그리고 이 속성들은 상속받은 자식클래스의 테이블에서 매핑한다.@AttributeOverride만약 부모로 부터 상속받은 매핑 정보를 재정의 하고자 할때는 @AttributeOverride를 사용하면 된다.@Entity@AttributeOverride(name = &quot;id&quot;, column = @Column(name = &quot;member_id&quot;))public class Member extends BaseEntity { private String email;}부모에게 상속 받은 id 속성을 member_id로 재정의 하는 코드이다.만약 둘 이상의 속성을 재정의 할때는 @AttributeOverrides를 사용하면 된다.@Entity@AttributeOverrides({ @AttributeOverride(name = &quot;id&quot;, column = @Column(name = &quot;member_id&quot;)), @AttributeOverride(name = &quot;name&quot;, column = @Column(name = &quot;member_name&quot;))})public class Member extends BaseEntity { private String email;}@MappedSupperclass의 특징 테이블과 매핑되지 않고 자식 클래스에 엔티티의 매핑 정보를 상속하기 위해 사용 @MappedSupperclass로 지정한 클래스는 엔티티가 아니므로 em.find()나 JPQL에서 사용 불가 이 클래스를 직접 생성하여 사용할 일은 거의 없으므로 추상 클래스로 만드는 것을 권장참고 인프런 자바 ORM 표준 JPA 프로그래밍 - 기본편(김영한) 자바 ORM 표준 JPA 프로그래밍" }, { "title": "상속관계 매핑", "url": "/posts/jpa-12/", "categories": "JPA", "tags": "JPA, 상속관계 매핑", "date": "2022-08-16 00:00:00 +0900", "snippet": "상속관계 매핑이번 포스팅에서는 상속관계 매핑에 대해서 알아보자.우선 객체지향 프로그래밍에서 상속이란 객체들 간의 관계를 구축하는 방법으로 객체(서브 클래스)가 다른 객체(슈퍼 클래스)의 속성과 동작을 상속받아 사용하는 것을 말한다.관계형 데이터베이스에는 이러한 객체지향 언어에서 다루는 상속이라는 개념이 존재하지 않는다. 대신 슈퍼타입 서브타입관계 라는 모델링 기법이 객체의 상속 개념과 가장 유사하다.ORM에서 말하는 상속 관계 매핑은 객체지향의 상속과 데이터베이스의 슈퍼타입 서브타입 관계를 매핑하는 것을 말한다.슈퍼타입 서브타입 논리 모델을 실제 물리 모델인 테이블로 구현할 수 있는 방법이 3가지가 있는데 JPA는 이러한 3가지 방식을 통해 두 모델(상속, 슈퍼타입 서브타입)을 매핑한다. 각각의 테이블로 변환: 각각을 테이블로 만들고 조회시 조인 사용 통합 테이블로 변환: 테이블을 하나만 사용하여 통합하는 방식, JPA에서는 단일 테이블 전략이라 한다. 서브타입 테이블로 변환: 서브 타입마다 하나의 테이블을 만드는 방식, JPA에서는 구현 클래스마다 테이블 전략이라 한다.조인전략 (Joined Strategy)조인전략은 각각을 모두 테이블로 만들고 조회 시 조인을 활용하는 방식이다.이 전략을 사용할 때 주의점은 객체는 타입으로 구분할 수 있지만 테이블은 타입의 개념이 없다는 점이다.따라서 타입을 구분하는 컬럼을 추가해야 한다.JPA를 통해 조인전략을 사용하는 코드를 살펴보자.@Entity@Inheritance(strategy = InheritanceType.JOINED)@DiscriminatorColumn(name = &quot;DTYPE&quot;)public abstract class Item { @Id @GeneratedValue @Column(name = &quot;ITEM_ID&quot;) private Long id; private String name; private int price;}@Entity@DiscriminatorValue(&quot;A&quot;)public class Album extends Item { private String artist;}@Entity@DiscriminatorValue(&quot;M&quot;)public class Movie extends Item { private String director; private String actor;}@Entity@DiscriminatorValue(&quot;B&quot;)public class Book extends Item { private String author; private String isbn;}JPA를 통해 Item과 Album, Movie, Book 엔티티를 표현하였다. 위 코드의 매핑정보를 분석해보자. @Inheritance(strategy = InheritanceType.JOINED): 상속 매핑을 사용할 때는 부모 클래스에 @Inheritance를 사용해여 매핑전략을 지정해줘야 한다. 여기서는 조인전략을 사용하므로 strategy = InheritanceType.JOINED가 사용되었다. @DiscriminatorColumn(name = “DTYPE”): 앞서 언급하였듯 테이블에는 타입의 개념이 없기 때문에 타입을 구분하는 컬럼을 추가해야 한다고 하였고 이를 표현하는 어노테이션이다. 기본값은 DTYPE을 사용하므로 여기서는 @DiscriminatorColumn 사용하여도 무방하다. @DiscriminatorValue(“A”): 엔티티를 저장할 때 구분 컬럼에 입력할 값을 지정한다. 이처럼 A라고 작성되었다면 Album을 저장할 때 부모 엔티티의 구분 컬럼(DTYPE)에 A가 저장된다.장점 테이블 정규화 외래 키 참조 무결성 제약조건 활용 가능 저장공간을 효율적으로 사용단점 조회할 때 조인이 많이 사용되므로 성능이 저하될 수 있음 조회 쿼리가 복잡해짐 데이터를 등록할 때 INSERT QUERY가 두번 실행단일 테이블 전략 (Single-Table Strategy)단일 테이블 전략은 이름 그대로 테이블을 하나만 사용하는 전략이다. 그리고 구분 컬럼(DTYPE)을 통해 데이터를 구분한다. 조회 시 조인을 사용하지 않으므로 일반적인 경우 가장 빠르다.이 전략을 사용할 때의 주의점은 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다는 점이다.@Entity@Inheritance(strategy = InheritanceType.SINGLE_TABLE)@DiscriminatorColumn(name = &quot;DTYPE&quot;)public abstract class Item { @Id @GeneratedValue @Column(name = &quot;ITEM_ID&quot;) private Long id; private String name; private int price;}@Entity@DiscriminatorValue(&quot;A&quot;)public class Album extends Item { private String artist;}@Entity@DiscriminatorValue(&quot;M&quot;)public class Movie extends Item { private String director; private String actor;}@Entity@DiscriminatorValue(&quot;B&quot;)public class Book extends Item { private String author; private String isbn;}장점 조인을 사용하지 않으므로 일반적인 경우 가장 빠른 조회 성능 조회 쿼리가 단순함단점 자식 엔티티가 매핑한 컬럼은 모두 null 허용 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있음, 이로인해 상황에 따라 조회 성능이 오히려 느려질 수 있음구현 클래스 마다 테이블 전략 (Table-per-Concrete-Class Strategy)구현 클래스마다 테이블 전략은 자식 엔티티마다 테이블을 각각 만드는 전략을 말한다.@Entity@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)public abstract class Item { @Id @GeneratedValue @Column(name = &quot;ITEM_ID&quot;) private Long id; private String name; private int price;}@Entitypublic class Album extends Item { private String artist;}@Entitypublic class Movie extends Item { private String director; private String actor;}@Entitypublic class Book extends Item { private String author; private String isbn;}장점 서브 타입을 구분해서 처리할 때 효과적 not null 제약조건을 사용할 수 있음단점 여러 자식 테이블을 함께 조회할 때 성능 저하(UNION 사용으로 인해) 자식 테이블을 통합하여 쿼리하기 어려움해당 방식은 데이터베이스 설계자와 ORM 전문가 둘 다 추천하지 않는 전략으로 조인이나 단일 테이블 전략을 고려하는 것이 좋다.참고 인프런 자바 ORM 표준 JPA 프로그래밍 - 기본편(김영한) 자바 ORM 표준 JPA 프로그래밍" }, { "title": "양방향 연관관계", "url": "/posts/jpa-11/", "categories": "JPA", "tags": "JPA, 양방향 연관관계", "date": "2022-08-06 00:00:00 +0900", "snippet": "양방향 연관관계양방향 연관관계는 이전 게시글에서 다룬 단방향 연관관계와 다르게 Member에서 Team으로의 접근 뿐만 아니라 Team에서도 Member에 접근할 수 있는 이름 그대로 양방향에서 매핑이 가능한 것을 말한다.객체 연관관계를 살펴보면 member는 하나의 team을 가질 수 있다. 반대로 team은 여러 member를 가질 수 있다. 그렇기 때문에 team은 컬렉션으로 member 정보를 가지고 있어야한다. 회원 -&amp;gt; 팀 [ Member.team ] 팀 -&amp;gt; 회원 [ Team.mebmers(List) ]이제 테이블에서의 관계를 생각해보자. 테이블은 객체와 달리 외래 키 하나로 양방향으로 조회가 가능하다.객체의 경우는 위와 같이 필드 하나로 양방향 접근이 불가능 하여 단방향 접근이 가능한 각각의 필드(Member.team, Team.members)를 사용하였다.결론적으로 테이블은 외래 키 하나만으로 양방향 조회가 가능하므로 처음부터 양방향 관계이다. 따라서 양방향 관계를 위해 별도의 작업은 필요치 않다.@Entityclass Member { @Id1 private Long memberId; // 연관관계 매핑 @ManyToOne @JoinColumn(name = &quot;team_id&quot;) private Team team; private String username;}class Team { private Long teamId; private String name; //== 양방향 매핑을 위해 필드 추가==// @OneToMany(mappedBy = &quot;team&quot;) private List&amp;lt;Member&amp;gt; members = new ArrayList&amp;lt;&amp;gt;();}기존 단뱡향 관계를 양방향 관계로 변경하기 위해서 Team 엔티티에 members 필드를 추가하였다. 팀의 입장에서는 여러 회원을 가질 수 있으므로 컬렉션 타입인 List 타입을 가진다.그리고 일대다 관계를 매핑하기 위해 `@OneToMany` 어노테이션을 사용하였다. `mappedBy` 속성은 양방향 매핑일 때 사용하는데 반대쪽 매핑의 필드 이름을 값으로 주면 된다.일대다 컬렉션 조회아래의 예제는 객체 그래프 탐색을 사용하여 팀에서 회원 목록을 조회하는 예제이다.public void findMembers() { Team team = em.find(Team.class, &quot;team1&quot;); List&amp;lt;Member&amp;gt; members = team.getMembers();}연관관계의 주인JPA에서 양방향 매핑을 공부하다보면 연관관계의 주인이라는 이야기를 많이 들어볼 것이다. 양방향 매핑에서 @OneToMany를 사용하여 일대다 관계를 나타내고 Member를 컬렉션 타입으로 가지는 것까지는 직관적으로 이해가 될것이다.그렇다면 mappedBy 속성은 왜 필요한 것일까? @OneToMany를 통해 Team과 Member가 일대다 관계에 있다는 정보를 충분히 제공할 수 있을 것 같은데 말이다.이를 설명하기 위해 위에서 테이블과 객체의 연관관계의 차이점에 대해 다시 언급하려 한다.테이블은 외래 키 하나로 양방향 관계를 나타낼 수 있었다. 하지만 객체의 경우는 어떠한가? 엄밀히 말해 객체에는 양방향 연관관계라는 것이 존재하지 않는다. 서로 다른 단방향 연관관계 2개를 애플리케이션 로직으로 잘 묶어서 양방향인 것처럼 보이게 할 뿐이다.외래 키는 누가 관리하는가?테이블의 경우는 외래 키를 하나만 관리한다. 그리고 우리는 보통 자식 테이블에서 외래 키를 관리한다. 단방향 관계일 경우 객체에서 참조 필드를 가지고 있는 곳에서 외래 키를 관리하면 되었다.둘다 매핑 정보(참조 필드, 외래 키)를 관리하는 포인트는 한 곳이다.그럼 양방향 관계의 경우를 살펴보자. 테이블에서는 별다른 작업이 없었으므로 변동사항이 없다. 하지만 객체의 경우 members 필드가 추가되면서 매핑 정보가 두개가 되었다.다시말해 객체의 참조는 두개인데 외래 키는 하나이다. 여기에서 차이가 발생된다.객체의 입장에서 보면 둘 중 어떤 관계를 사용하여 외래 키를 관리해야 할까? 이런 차이로 인해 JPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래 키를 관리해야 하는데 이것을 연관관계의 주인이라 한다.양방향 매핑의 규칙: 연관관계 주인양방향 관계를 사용하기 위해서는 지켜야할 규칙이 있는데 두개의 매핑정보(Member.team, Team.members) 중 하나를 연관관계의 주인으로 정해야한다.그리고 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리(등록, 수정, 삭제)할 수 있다. 반면에 주인이 아닌 쪽은 읽기만 가능하다. 주인은 mappedBy 속성을 사용하지 않는다. 주인이 아니라면 mappedBy 속성을 사용하여 속성의 값으로 연관관계 주인을 지정해야 한다.연관관계 주인을 정한다는 것은 한마디로 외래 키 관리자를 선택하는 것이다.테이블의 다대일, 일대다 관계에서는 항상 다 쪽이 외래 키를 가진다. 다 쪽인 @ManyToOne은 항상 연관관계의 주인이 된다.따라서 @ManyToOne의 경우는 mappedBy를 설정할 수 없으므로 mappedBy 속성을 지원하지 않는다.양방향 연관관계 저장양방향 연관관계를 사용하여 엔티티를 저장하는 예제이다.public void save() { // 팀1 저장 Team team1 = new Team(&quot;team1&quot;, &quot;팀1&quot;); em.persist(team1); // 회원1 저장 Member member1 = new Member(&quot;member1&quot;, &quot;회원1&quot;); member1.setTeam(team1); // 연관관계 설정 em.persist(member1);}위 코드를 살펴보면 연관관계의 주인인 Member(team 필드)를 통해서 회원과 팀의 연관관계를 설정하고 저장하는 것을 볼 수 있다. 이는 이전 단방향 연관관계에서 살펴본 회원과 팀을 저장하는 예제와 동일하다.그렇다면 연관관계의 주인이 아닌 곳에서 연관관계를 지정하면 어떻게 될까?public void save() { // 회원1 저장 Member member1 = new Member(&quot;member1&quot;, &quot;회원1&quot;); em.persist(member1); // 팀1 저장 Team team1 = new Team(&quot;team1&quot;, &quot;팀1&quot;); team1.getMembers().add(member1); // 무시(연관관계 주인이 아님) em.persist(team1);}위의 경우는 연관관계의 주인이 아닌 Team(members 필드)을 통해서 연관관계를 설정하여 저장을 시도한다. 이 경우는 위에서 언급하였듯 연관관계 주인이 아닌 필드는 읽기만 가능하기 때문에주인이 아닌 곳에서 입력된 값은 외래 키에 영향을 주지 않는다.그리고 이것이 양방향 연관관계를 사용할 때의 주의점이다. 연관관계의 주인에는 값을 입력하지 않고, 주인이 아닌 곳에만 값을 입력하는 것인데외래 키 값이 정상적으로 저장되지 않는다면 이것부터 의심해보자.순수한 객체까지 고려한 양방향 연관관계외래 키를 저장하기 위해서는 연관관계 주인에 값을 세팅해야 한다. 그렇다면 연관관계의 주인이 아닌 곳에 값을 지정하는 것이 의미가 없는 것인가?객체 관점에서는 양쪽 방향에 모두 값을 입력해주는 것이 가장 안전하다. 이유는 객체 입장에서는 단방향 2개를 이용해 양방향인 것처럼 표현하고 있다.그렇다면 만약 한쪽에만 값이 지정되어 있고 반대쪽에 값이 없다면 데이터를 조회하는 시점에 불일치 되는 현상이 발생될 수 있다. 이는 우리가 기대하는 양방향 연관관계의 결과가 아닐 것이다.public void test() { Team team1 = new Team(&quot;team1&quot;, &quot;팀1&quot;); Member member1 = new Member(&quot;member1&quot;, &quot;회원1&quot;); Member member2 = new Member(&quot;member2&quot;, &quot;회원2&quot;); member1.setTeam(team1); // 연관관계 설정 member2.setTeam(team1); // 연관관계 설정 List&amp;lt;Member&amp;gt; members = team1.getMembers(); System.out.println(members.size()); // 결과: 0}위 코드를 살펴보면 연관관계의 주인인 Member를 통해 Team을 설정하였다. 그렇다면 Team의 입장에서는 두 개의 Member를 가지고 있는 결과가 된다.하지만 Member.team에만 값을 설정하였기 때문에 Team.members의 size는 0인 결과가 나온다.public void test() { Team team1 = new Team(&quot;team1&quot;, &quot;팀1&quot;); Member member1 = new Member(&quot;member1&quot;, &quot;회원1&quot;); Member member2 = new Member(&quot;member2&quot;, &quot;회원2&quot;); member1.setTeam(team1); // 연관관계 설정 team1.getMembers().add(member1); member2.setTeam(team1); // 연관관계 설정 team1.getMembers().add(member2); List&amp;lt;Member&amp;gt; members = team1.getMembers(); System.out.println(members.size()); // 결과: 2}이렇게 양쪽 모두 관계를 설정하면 결과했던 2가 출력된다. 이렇듯 객체의 관계까지 고려하여 양쪽 모두 연관관계를 설정하는 것이 좋다.참고 인프런 자바 ORM 표준 JPA 프로그래밍 - 기본편(김영한) 자바 ORM 표준 JPA 프로그래밍" }, { "title": "단방향 연관관계", "url": "/posts/jpa-10/", "categories": "JPA", "tags": "JPA, 단방향 연관관계", "date": "2022-08-05 00:00:00 +0900", "snippet": "단방향 연관관계단방향 연관관계는 1 : N(1대다)인 경우를 말한다. 이 경우는 한 쪽의 엔티티가 관계를 맺은 엔티티 쪽의 여러 객체를 가질 수 있다는 것을 의미한다. 팀은 다수의 회원을 포함하고 있다. 하나의 주문에는 다수의 주문상품이 포함된다. 상위 카테고리는 다수의 하위 카테고리를 가지고 있다.테이블 연관관계테이블은 외래 키를 활용하여 연관관계를 맺는다. 그리고 외래 키를 통해서 테이블을 조인할 수 있는데 외래 키가 두 테이블 중 어디에 있든 조인이 가능하다. (양방향 관계)select *from member mjoin team t on t.team_id = m.team_idselect *from team tjoin member m on m.team_id = t.team_id객체 연관관계객체의 경우 필드를 이용하여 연관관계를 맺는다. 객체는 테이블과 다르게 연관관계 필드가 있는 객체에서만 접근이 가능하다. (단방향 관계)class Member { private Long memberId; private Team team; private String username;}class Team { private Long teamId; private String name;}Member member = new Member();member.getTeam();Member에서는 Team에 접근할 수 있지만 Team은 member의 정보가 없기 때문에 접근할 수 없다.객체 연관관계 vs 테이블 연관관계객체 객체는 참조(주소)로 연관관계를 맺는다. 참조를 사용하는 객체의 연관관계는 단방향이다.테이블 테이블은 외래 키로 연관관계를 맺는다. 외래 키를 사용하는 테이블의 연관관계는 양방향이다.객체 관계 매핑위에서 객체와 테이블의 연관관계 방법 및 차이점을 알아보았다. 이제 JPA를 활용하여 객체와 테이블을 매핑하는 방법을 알아보자.@Entityclass Member { @Id1 private Long memberId; // 연관관계 매핑 @ManyToOne @JoinColumn(name = &quot;team_id&quot;) private Team team; private String username;}class Team { private Long teamId; private String name;}@ManyToOne이름 그대로 다대일(N:1) 관계를 나타내는 매핑 정보이다. 회원과 팀은 다대일 관계에 있다.JPA에서는 연관관계를 표현할 때 이러한 다중성을 나타내는 어노테이션을 필수로 사용해야한다.@ManyToOne 속성 속성 기능 기본값 optional false로 설정하면 연관된 엔티티가 항상 있어야 한다. true fetch 글로벌 페치 전략을 설정한다. FetchType.EAGER cascade 영속성 전이 기능을 사용한다.   targetEntity 연관된 엔티티의 타입 정보를 설정한다. 이 기능은 거의 사용하지 않는다.컬렉션을 사용해도 제네릭으로 타입 정보를 알 수 있다.   @ManyToOne과 함께 사용된 어노테이션인 @JoinColumn은 외래 키를 매핑하기 위해 사용한다. 즉, @JoinColumn(name = &quot;team_id&quot;)에서 name의 값인 team_id는 외래키를 나타낸다.해당 어노테이션은 생략이 가능하다.@JoinColumn 속성 속성 기능 기본값 name 매핑할 외래 키 이름 필드명 + _ + 참조하는 테이블의기본 키 컬럼명 referencedColumnName 외래 키가 참조하는 대상 테이블의 컬럼명 참조하는 테이블의 기본 키 컬럼명 foreignKey(DDL) 외래 키 제약조건을 직접 지정할 수 있다.이 속성은 테이블을 생성할 때만 사용한다.   uniquenullableinsertableupdatablecolumnDefinitiontable @Column의 속성과 동일   @JoinColumn 생략 시@JoinColumn을 생략하게 되면 외래 키를 찾을 때 기본 전략을 사용한다.@ManyToOneprivate Team team;기본 전략: 필드명(tema) + _ + 참조하는 테이블의 컬럼명(team_id) -&amp;gt; team_team_id연관관계 사용저장연관관계를 매핑한 엔티티를 어떻게 저장하는지 예제로 알아보자.public void save() { // 팀1 저장 Team team1 = new Team(&quot;team1&quot;, &quot;팀1&quot;); em.persist(team1); // 회원1 저장 Member member1 = new Member(&quot;member1&quot;, &quot;회원1&quot;); member1.setTeam(team1); // 연관관계 설정 em.persist(member1);}연관관계를 매핑하기 위해 Member를 생성 후 member가 가지고 있는 setTeam(team1) 메소드로 Team을 설정하는 것을 볼 수 있다.Member 엔티티에 Team 필드에 값이 세팅되어 있는 상태로 Member가 저장되면 JPA가 참조하는 팀의 식별자를 외래 키로 사용하여 적절한 등록 쿼리를 생성한다.조회연관관계가 있는 엔티티를 조회하는 방법은 크게 2가지가 있다. 객체 그래프 탐색 (객체 연관관계를 사용한 조회) 객체지향 쿼리(JPQL) 사용객체 그래프 탐색Member member = em.find(Member.class, &quot;member1&quot;);Team team = member.getTeam(); // 객체 그래프 탐색위 코드와 같이 객체를 통해 연관된 엔티티를 조회하는 것을 객체 그래프 탐색이라 한다.수정연관관계를 수정하는 방법을 코드를 통해 알아보자.public void update() { // 팀1 저장 Team team1 = new Team(&quot;team1&quot;, &quot;팀1&quot;); em.persist(team1); // 회원1 저장 Member member1 = new Member(&quot;member1&quot;, &quot;회원1&quot;); member1.setTeam(team1); // 연관관계 설정 em.persist(member1); // 새로운 팀2 생성 Team team2 = new Team(&quot;team2&quot;, &quot;팀2&quot;); em.persist(team2); // 회원1 조회 Member find = em.find(Member.class, &quot;member1&quot;); // 회원1에 팀2 설정 member.setTeam(team2);}영속상태의 Member를 조회 후 새로운 연관관계인 Team2로 값을 변경하게 되면 이후 트랜잭션을 커밋할 때 플러시가 발생되고변경감지 기능이 동작하여 연관관계가 변경된다.제거 (연관관계 제거)public void delete() { Member member1 = em.find(Member.class, &quot;member1&quot;); member1.setTeam(null);}영속상태의 Member를 조회 후 Team 값을 null로 변경하면 연관관계를 제거할 수 있다.연관된 엔티티 삭제만약 연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거후 삭제를 해야한다. 그렇지 않으면 외래 키 제약조건으로 인해데이터베이스 오류가 발생하게 된다. 예제의 경우로 다시 설명하면 Team1을 삭제하기 위해서는 Member1과 Team1의 연관관계를 우선 삭제해야 한다.member1.setTeam(null); // member1과 team1의 연관관계 제거em.remove(team1); // team1 삭제참고 인프런 자바 ORM 표준 JPA 프로그래밍 - 기본편(김영한) 자바 ORM 표준 JPA 프로그래밍" }, { "title": "필드와 컬럼 캐핑", "url": "/posts/jpa-09/", "categories": "JPA", "tags": "JPA, Column Mapping", "date": "2022-08-04 00:00:00 +0900", "snippet": "필드와 컬럼 매핑@Column엔티티 클래스의 필드와 데이터베이스의 컬럼을 매핑하기 위해 JPA에서는 @Column 어노테이션을 지원한다.@Column 어노테이션은 가장 많이 사용되고 기능도 많지만 name, nullable이 주로 사용되고 나머지는 잘 사용되지 않는 편이다. 속성 기능 기본값 name 필드와 매핑할 테이블의 컬럼 이름 객체의 필드 이름 insertable(거의 사용하지 않음) 엔티티 저장 시 이 필드도 같이 저장한다. false로 설정하면 이 필드는 데이터베이스에저장하지 않는다. false 옵션은 읽기 전용일 때 사용한다. true updatable(거의 사용하지 않음) 엔티티 수정 시 이필드도 같이 수정한다. false로 설정하면 데이터베이스에수정하지 않는다. false 옵션은 읽기 전용일 때 사용한다. true table(거의 사용하지 않음) 하나의 엔티티를 두 개 이상의 테이블에 매핑할 때 사용한다.지정한 필드를 다른 테이블에 매핑할 수 있다. 현재 클래스가 매핑된 테이블 nullable(DDL) null 값의 허용 여부를 설정한다. false로 설정하면 DDL 생성 시not null 제약조건이 붙는다. ture unique(DDL) @Table의 uniqueConstraints와 같지만 한 컬럼에 간단히유니크 제약조건을 걸 때 사용한다. 만약 두 컬럼 이상을 사용해서 유니크 제약조건을사용하려면 클래스 레벨에서 @Table.uniqueConstrainsts를 사용해야 한다.   columnDefinition(DDL) 데이터베이스 컬럼 정보를 직접 줄 수 있다. 필드의 자바 타입과 방언 정보를사용하여 적절한 컬럼 타입을 생성한다. length(DDL) 문자 길이 제약조건, String 타입에만 사용한다. 255 precision, scale(DDL) BigDecimal 타입에서 사용한다(BigInteger도 사용할 수 있다). precision은소수점을 포함한 전체 자릿수를, scale은 소수의 자릿수이다.참고로 double, float 타입에는 적용되지 않는다.아주 큰 숫자나 정밀한 소수를 다루어야 할 때만 사용한다. precision=19, scale=2 @Entity@Table(name = &quot;tb_member&quot;)public class Member { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(precision = 19, name = &quot;member_id&quot;) private Long id; @Column(name = &quot;member_nm&quot;, length = 100, nullable = false) private String memberNm; @Column(insertable = true, updatable = false) private LocalDateTime createdAt; @Column(insertable = true, updatable = true) private LocalDateTime updatedAt; private Integer age;}@Column 속성 생략 시위 예제의 age 필드와 같이 @Column 속성을 생략하게 되면 어떻게 될까? 대부분 @Column 속성의 기본값이 적용되는데, 자바 기본 타입일 때는 nullable 속성에 예외가 있다.int data1; // @Column 생략, 자바 기본 타입data1 integer not null // 생성된 DDL자바의 기본 타입에는 null을 입력할 수 없다. 그로 인해 not null 제약조건이 추가되었다.Integer data2; // @Column 생략, 객체 타입data2 integer // 생성된 DDLInteger의 경우는 객체 타입이므로 null 값이 허용된다. 그로인해 not null 제약조건이 추가되지 않았다.@Columnint data3; // @Column 사용, 자바 기본 타입data3 integer // 생성된 DDL이 경우는 int가 기본 타입이지만 @Column 어노테이션의 nullable 속성의 기본 값이 ture이기 때문에 not null 제약조건이 추가되지 않았다. 이 경우 nullable = false를 지정하는 것이 안전하다.@Enumerated자바의 enum 타입을 매핑할 때 사용한다. 속성 기능 기본값 value EnumType.ORDINAL: enum 순서를 데이터베이스에 저장EnumType.STRING: enum 이름을 데이터베이스에 저장 EnumType.ORDINAL @Entity@Table(name = &quot;tb_member&quot;)public class Member { ... @Enumerated(EnumType.STRING) private Role role = Role.ADMIN; // 데이터베이스에 문자 ADMIN으로 저장 @Enumerated(EnumType.ORDINAL) private Role role = Role.USER; // 데이터베이스에 enum 순서인 1이 저장된다. (ADMIN:0, USER:1)}enum Role { ADMIN, USER}EnumType.ORDINAL 장점: 데이터베이스에 저장되는 데이터 크기가 작다. 단점: 이미 저장된 enum의 순서를 변경할 수 없다.EnumType.STRING 장점: 저장된 enum의 순서가 바뀌거나 enum이 추가되어도 안전하다. 단점: 데이터베이스에 저장되는 데이터 크기가 ORDINAL에 비해서 크다.@Temporal날짜 타입(java.util.Date, java.util.Calendar)을 매핑할 때 사용한다. 속성 기능 기본값 value TemporalType.DATE: 날짜, 데이터베이스 date 타입과 매핑(예: 2022-08-04)TemporalType.TIME: 시간, 데이터베이스 time 타입과 매핑(예: 11:11:11)TemporalType.TIMESTAMP: 날짜와 시간,데이터베이스 timestamp 타입과매핑(예: 2022-08-04: 11:11:11) EnumType.ORDINAL @Lob데이터베이스 BLOB, CLOB 타입과 매핑하고 지정할 수 있는 속성이 없다. 매핑하는 필드 타입이 문자면 CLOB으로 매핑하고 나머지는 BLOB으로 매핑한다. CLOB: String, char[], java.sql.CLOB BLOB: byte[], java.sql.BLOB@Transient엔티티의 필드를 컬럼과 매핑하고 싶지 않을 때 사용하는 어노테이션이다. 따라서 데이터베이스에 해당 필드를 저장하지도 조회하지도 않는다.객체에 임시로 어떤 값을 보관하고 싶을 때 사용한다.@AccessJPA가 엔티티 데이터에 접근하는 방식을 지정한다. 필드 접근(AccessType.FIELD): 필드에 직접 접근한다. 이 경우 필드가 private으로 지정되어 접근할 수 있다. 프로퍼티 접근(AccessType.PROPERTY): 접근자(Getter)를 사용하여 필드에 접근한다.참고 인프런 자바 ORM 표준 JPA 프로그래밍 - 기본편(김영한) 자바 ORM 표준 JPA 프로그래밍" }, { "title": "기본 키 매핑", "url": "/posts/jpa-08/", "categories": "JPA", "tags": "JPA, Entity Mapping", "date": "2022-08-02 00:00:00 +0900", "snippet": "기본 키 매핑기본 키 매핑은 @Id 어노테이션을 사용하여 테이블의 기본키와 매핑시키는 것이다.테이블에 새로운 데이터를 생성하기 위해서는 기본 키가 필수적으로 필요하게 되고 JPA는 이러한 기본 키를 생성하기 위한 몇가지 전략을 제공한다. 직접할당: 기본 키를 애플리케이션에서 직접 할당 자동생성: 대리 키 사용 방식 IDENTITY: 기본 키 생성을 데이터베이스에 위임 SEQUENCE: 데이터베이스 시퀀스를 사용하여 기본 키 할당 TABLE: 키 생성 테이블을 사용 기본 키 직접 할당 전략기본 키를 직접 할당하기 위해서는 @Id 어노테이션을 사용하여 매핑하면 된다.@Id@Column(name = &quot;member_id&quot;)private String id;기본 키를 직접 할당 하기 위해서는 em.persist()로 엔티티를 영속화 하기 전에 애플리케이션에서 기본 키를 직접할당 해야한다.Member member = new Member();member.setId(&quot;memberA&quot;);em.persist(member);IDENTITY 전략IDENTITY 전략은 기본 키 생성을 데이터베이스에 위임하는 전략이다. 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용된다.예로 MySQL에서 해당 전략을 사용하게 되면 MySQL의 AUTO_INCREMENT 기능을 사용하여 기본 키를 자동으로 생성해준다.@Entity@Table(name = &quot;tb_member&quot;)public class Member { @Id // 기본 키 매핑 @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;member_id&quot;) private Long id; @Column(name = &quot;member_nm&quot;) private String memberNm; private Integer age;}IDENTITY 전략 사용 시 주의엔티티가 영속 상태가 되려면 식별자가 반드시 필요하다. 하지만 IDENTITY 전략을 사용하는 경우는 데이터가 실제 INSERT 되기 전까지 식별자를 알 수 없다.그로인해 em.persist()를 호출하는 즉시 INSERT SQL이 데이터베이스에 전달된다. 따라서 해당 전략은 트랜잭션을 지원하는 쓰기지연이 동작하지 않는다.SEQUENCE 전략데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트로 SEQUENCE 전략은 이 시퀀스를 사용하여 기본 키를 생성하는 전략이다.@Entity@Table(name = &quot;tb_member&quot;)public class Member { @Id // 기본 키 매핑 @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;member_seq_generator&quot;) // 시퀀스 생성기 선택 @Column(name = &quot;member_id&quot;) private Long id; @Column(name = &quot;member_nm&quot;) private String memberNm; private Integer age;}IDENTITY 전략과 SEQUENCE 전략IDENTITY 전략 사용시에는 em.persist() 호출 뒤 INSERT SQL 바로 발생되는 반면에 SEQUENCE 전략의 경우는em.persist()를 호출할 때 먼저 데이터베이스 시퀀스를 사용하여 식별자를 조회한다. 그리고 조회한 식별자를 엔티티에 할당한 후 엔티티를 영속성 컨텍스트에 저장한다.이후 트랜잭션을 커밋하여 플러시가 발생되면 엔티티를 데이터베이스에 저장한다.Table 전략Table 전략은 식별자 생성 전용 테이블을 만들고 이를 활용하여 데이터베이스 시퀀스를 흉내내는 전략이다.해당 전략은 테이블을 사용하므로 시퀀스를 지원하지 않는 데이터베이스에서도 사용이 가능하다는 장점이 있다.create table sequences ( sequence_name varchar(255) not null, next_val bigint, primary key (sequence_name));@Entity@TableGenerator( name = &quot;member_sequence_generator&quot;, table = &quot;sequences&quot;, pkColumnValue = &quot;member_sequence&quot;)@Table(name = &quot;tb_member&quot;)public class Member { @Id // 기본 키 매핑 @GeneratedValue(strategy = GenerationType.TABLE, generator = &quot;member_sequence_generator&quot;) @Column(name = &quot;member_id&quot;) private Long id; @Column(name = &quot;member_nm&quot;) private String memberNm; private Integer age;}AUTO 전략AUTO 전략의 경우는 데이터베이스 방언에 따라 JPA가 자동으로 IDENTITY, SEQUENCE, TABLE 전략 중 하나를 선택하는 전략이다.예를 들어 오라클의 경우는 SEQUENCE를 MySQL의 경우는 IDENTITY를 사용한다.참고 인프런 자바 ORM 표준 JPA 프로그래밍 - 기본편(김영한) 자바 ORM 표준 JPA 프로그래밍" }, { "title": "엔티티 매핑", "url": "/posts/jpa-07/", "categories": "JPA", "tags": "JPA, Entity Mapping", "date": "2022-08-02 00:00:00 +0900", "snippet": "엔티티 매핑JPA를 사용함에 있어 가장 중요한 것은 엔티티와 테이블을 매핑하는 것이다. JPA는 다양한 매핑 어노테이션을 지원하고 크게 4가지로 분류할 수 있다. 객체와 테이블 매핑: @Entity, @Table 기본 키 매핑: @Id 필드와 컬럼 매핑: @Column 연관관계 매핑: @ManyToOne, @JoinColumn, @OneToMany, @ManyToMany@EntityJPA를 사용할 때 테이블과 매핑되는 엔티티 클래스에 필수로 붙여야 하는 어노테이션이다. 그리고 엔티티 클래스의 경우몇 가지 주의사항이 있다. 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자) final 클래스, enum, interface, inner 클래스에는 사용 불가 저장할 필드에 final 사용 불가@Table@Table 어노테이션은 엔티티와 매핑할 테이블을 지정할 때 사용한다. 생략하게 되면 엔티티 이름을 테이블 명으로 사용한다.@Entity@Table(name = &quot;tb_member&quot;) // 생략 시 테이블은 엔티티 명칭인 member로 매핑된다.public class Member { @Id // 기본 키 매핑 @Column(name = &quot;member_id&quot;) // 컬럼 매핑 private Long id; @Column(name = &quot;member_nm&quot;) private String memberNm; private Integer age; // @Column 생략 시 필드 명칭인 age로 매핑된다.}참고 인프런 자바 ORM 표준 JPA 프로그래밍 - 기본편(김영한) 자바 ORM 표준 JPA 프로그래밍" }, { "title": "병합(Merge)", "url": "/posts/jpa-06/", "categories": "JPA", "tags": "JPA, 병합, Merge", "date": "2022-08-01 00:00:00 +0900", "snippet": "병합준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 병합을 사용하면 된다. merge() 메소드는 준영속 상태의 엔티티를 받아서그 정보로 새로운 영속 상태의 엔티티를 반환한다.준영속 병합 예제public class ExamMerge { static EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;jpaTest&quot;); public static void main(String[] args) { Member member = createMember(&quot;memberA&quot;, &quot;회원A&quot;); // 1 member.setUsername(&quot;회원명 변경&quot;); // 준영속 상태 2 mergeMember(member); // 3 } static Member createMember(String id, String username) { //== 영속성 컨텍스트1 시작 ==// EntityManager em1 = emf.createEntityManager(); EntityTransaction tx1 = em1.getTransaction(); tx1.begin(); Member member = new Member(); member.setId(id); member.setUsername(username); em1.persist(member); tx1.commit(); em1.close(); //== 영속성 컨텍스트1 종료 ==// return member; } static void mergeMember(Member member) { //== 영속성 컨텍스트2 시작 ==// EntityManager em2 = emf.createEntityManager(); EntityTransaction tx2 = em2.getTransaction(); tx2.begin(); Member mergeMember = em2.merge(member); tx2.commit(); // 4 //준영속 상태 System.out.println(&quot;member = &quot; + member.getUsername()); //영속상태 System.out.println(&quot;mergeMember = &quot; + mergeMember.getUsername()); System.out.println(&quot;em2 contains member = &quot; + em2.contains(member)); //false System.out.println(&quot;em2 contains mergeMember = &quot; + em2.contains(mergeMember)); //true em2.close(); //== 영속성 컨텍스트2 종료 ==// }} member 엔티티는 createMember() 메소드의 영속성 컨텍스트1에서 영속 상태 였지만 메소드가 종료되고 준영속 상태가 되었다. 준영속 상태에서 값을 변경하였기 때문에 변경감지가 동작하지 않아 실제 데이터 베이스에서 값이 변경되지 않는다. mergeMember() 메소드에서 member가 영속성 컨텍스트2에 영속 상태로 병합된다. 이때 member 값을 통해 새로운 mergeMember를 생성하게 되고 트랜잭션을 커밋할 때 변경감지를 통해 update 쿼리가 발생된다.Merge 동작 방식 merge()를 실행한다. 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회한다. 2.1. 만약 1차 캐시에 엔티티가 없으면 데이터 베이스에서 엔티티를 조회하고 1차 캐시에 저장한다. 조회한 영속 엔티티(mergeMember)에 member 엔티티의 값을 채워 넣는다. mergeMember를 반환한다.비영속 병합병합은 비영속 엔티티도 영속 상태로 만들 수 있다.Member member = new Member();Member newMember = em.merge(member); // 비영속 병합tx.commit();이 경우 파라미터로 넘어온 식별자로 엔티티를 조회할 수 없게 되는데 이때는 새로운 엔티티를 생성하여 병합한다.정리merge() 메서드는 준영속 상태의 엔티티를 다시 영속 상태로 변경해 준다. 하지만 이때 파라미터로 전달받은 엔티티를 영속상태로 변경하는 것이 아닌영속 상태의 새로운 엔티티를 생성하여 반환해 준다. 그로 인해 파라미터로 전달 받은 엔티티는 여전히 준영속 상태로 남아있게 된다.참고 인프런 자바 ORM 표준 JPA 프로그래밍 - 기본편(김영한) 자바 ORM 표준 JPA 프로그래밍" }, { "title": "준영속 상태", "url": "/posts/jpa-05/", "categories": "JPA", "tags": "JPA, 준영속 상태", "date": "2022-08-01 00:00:00 +0900", "snippet": "준영속 상태영속성 컨테스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된(detached) 것을 준영속 상태라 한다.따라서 준영속 상태가 된 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없게된다.준영속 상태 만들기영속 상태의 엔티티를 준영속 상태로 만드는 방법은 크게 3가지가 있다. em.detach(entity): 특정 엔티티만 준영속 상태로 전환 em.clear(): 영속성 컨텍스트를 완전히 초기화 em.close(): 영속성 컨텍스트를 종료em.detach()em.detach() 메소드는 특정 엔티티를 준영속 상태로 만든다.class Test() { public void detachTest() { Member member = new Member(); member.setId(&quot;memberA&quot;); member.setUsername(&quot;회원A&quot;); //영속 상태 em.persist(member); //준영속 상태 em.detach(member); }}em.detach()를 호출하게 되면 영속성 컨텍스트가 더는 해당 엔티티를 관리하지 않게되고 1차 캐시부터 쓰기 지연 SQL 저장소까지 해당 엔티티를관리하기 위한 모든 정보가 제거된다.em.clear()em.detach()가 특정 엔티티만을 준영속 상태로 만든다면 em.clear는 영속성 컨텍스트를 초기화 하여 해당 영속성 컨텍스트가 관리하던 모든 엔티티를 준영속 상태로 만든다.class Test() { public void clearTest() { Member member = new Member(); member.setId(&quot;memberA&quot;); member.setUsername(&quot;회원A&quot;); //영속 상태 em.persist(member); //준영속 상태 em.clear(); }}이 경우는 영속성 컨텍스트를 초기화 하기 때문에 1차 캐시와 쓰기 지연 SQL 저장소에 있는 모든 영속 상태의 엔티티 정보를 제거한다.em.close()영속성 컨텍스트를 종료하면 해당 영속성 컨텍스트가 관리하던 영속 상태의 엔티티가 모두 준영속 상태가 된다.class Test() { public void closeEntityManager() { EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;jpaTest&quot;); EntityManager em = emf.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); // [트랜잭션] - 시작 Member memberA = em.find(Member.class, &quot;memberA&quot;); Member memberB = em.find(Member.class, &quot;memberB&quot;); transaction.commit(); // [트랜잭션] - 종료 em.close(); // 영속성 컨텍스트 종료 }}영속 상태의 엔티티는 주로 영속성 컨텍스트가 종료되면서 준영속 상태가 된다. 개발자가 직접 준영속 상태로 만드는 일은 드물다.준영속 상태의 특징거의 비영속 상태에 가깝다영속성 컨텍스트가 관리하지 않으므로 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한 영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지 않는다.식별자 값을 가지고 있다비영속 상태는 식별자 값이 없을 수도 있지만 준영속 상태는 이미 한번 영속 상태였으므로 반드시 식별자 값을 가지고 있다.지연 로딩을 할 수 없다준영속 상태는 영속성 컨텍스트가 더는 관리하지 않으므로 지연 로딩 시 문제가 발생한다.참고 인프런 자바 ORM 표준 JPA 프로그래밍 - 기본편(김영한) 자바 ORM 표준 JPA 프로그래밍" }, { "title": "플러시", "url": "/posts/jpa-04/", "categories": "JPA", "tags": "JPA, 영속성 컨텍스트, 1차 캐시", "date": "2022-06-21 00:00:00 +0900", "snippet": "플러시 (Flush)플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것을 말하고 아래의 경우에 발생된다. Transaction Commit 발생 EntityManager의 flush 메서드 호출 JPQL 쿼리 실행동작 과정플러시가 발생되면 변경감지를 통해 영속성 컨텍스트 내에 관리되는 엔티티들을 스냅샷과 비교하여 수정 쿼리를 생성한다.이후 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다. (등록, 수정, 삭제) 변경감지 (Dirty Checking) 수정 쿼리를 쓰기 지연 SQL 저장소에 등록 쓰기 지연 SQL 저장소의 쿼리 데이터베이스에 전송Flush와 Transaction Commit데이터베이스는 Transaction Commit이 발생되지 않으면 변경내용을 반영하지 않는다. 또한 변경 내용을 SQL로 전달하지 않고 Transaction Commit만 발생되는 경우도 마찬가지로어떠한 내용도 반영되지 않는다.이로인해 JPA는 Transaction Commit 발생 시점에 플러시를 자동 호출하여 SQL를 전달 후 commit을 통해 변경을 반영한다.주의할 점은 플러시는 영속성 컨텍스트에 보관 된 엔티티를 지우는 것이 아니라 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업이다.JPQL 쿼리 실행 시 플러시가 자동으로 호출되는 이유JPQL이나 Criteria 같은 객체지향 쿼리를 호출할 때도 JPA는 자동으로 플러시를 발생 시킨다.em.persist(memberA);em.persist(memberB);em.persist(memberC);//중간에 JPQL 실행query = em.createQuery(&quot;select m from Member m&quot;, Member.class);List&amp;lt;Member&amp;gt; members= query.getResultList();코드를 보면 memberA, memberB, memberC는 영속성 컨텍스트에는 존재하지만 데이터베이스에는 반영되지 않은 상태이다.이때 JPQL을 실행하게 되면 결과적으로 조회 데이터가 없는 상태가 된다.JPQL을 통해 조회 시 원하는 결과가 나오기 위해서는 플러시를 통해 영속성컨텍스트의 내용이 데이터베이스에 반영이 되어야 한다.이로 인해 JPA는 JPQL을 실행할 때 플러시를 자동 호출한다.플러시 모드 옵션 FlushModeType.AUTO: 커밋이나 쿼리를 실행할 때 플러시 (default) FlushModeType.COMMIT: 커밋할 때만 플러시참고 인프런 자바 ORM 표준 JPA 프로그래밍 - 기본편(김영한) 자바 ORM 표준 JPA 프로그래밍" }, { "title": "영속성 컨텍스트의 특징", "url": "/posts/jpa-03/", "categories": "JPA", "tags": "JPA, 영속성 컨텍스트, 1차 캐시", "date": "2022-05-24 00:00:00 +0900", "snippet": "영속성 컨텍스트의 이점영속성 컨텍스트가 엔티티를 관리하는 것은 다음과 같은 이점이 있다. 1차 캐시 동일성 보장 트랜잭션을 지원하는 쓰기 지연 변경 감지 지연 로딩1차 캐시영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 1차 캐시라 하고 영속성 컨텍스트가 관리하는 엔티티들은 모두 이곳에 저장된다. em.persist(member)를 통해 영속성 컨텍스트의 1차 캐시에 엔티티 저장 영속성 컨텍스트 내부에 @Id로 매핑한 식별자를 키로 가지고 엔티티 인스턴스를 값으로 가지는 Map이 존재엔티티 조회 - 1차 캐시에서 조회em.find()를 통해 엔티티를 조회 시 JPA는 우선 1차 캐시에서 식별자 값으로 엔티티를 찾는다. 만약 찾고자 하는 엔티티가 있으면 데이터베이스를 조회하지 않고 메모리에 있는 1차 캐시에서 엔티티를 조회하여 반환한다. 1차 캐시 조회 1차 캐시에서 엔티티 반환 (1차 캐시에 엔티티가 있을 시)엔티티 조회 - 데이터 베이스에서 조회만약 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터 베이스에서 값을 조회한다. 그리고 조회된 값을 통해 엔티티를 생성하고 이를 1차 캐시에 저장한 후영속 상태의 엔티티를 반환한다. 1차 캐시 조회 데이터 베이스 조회 (1차 캐시에 엔티티가 없을 시) 1차 캐시에 엔티티 저장 엔티티 반환 (영속 상태)동일성 보장JPA는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에 대해서 동일성을 보장해 준다. 이는 영속성 컨텍스트 내부의 1차 캐시가 엔티티를 Map으로 캐싱하고 있기 때문에 같은 식별자(@Id)에 대해서 항상 같은 인스턴스에 접근하게 되므로 동일성이 보장된다.트랜잭션을 지원하는 쓰기 지연엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스의 엔티티를 저장하지 않는다.(트랜잭션 커밋직전까지 Insert Query를 보내지 않는다.)em.persist()를 통해 엔티티를 1차 캐시에 저장하고 Insert Query를 생성하여 쓰기지연 SQL 저장소에 저장한다. 트랜잭션이 커밋되는 시점에쓰기지연 SQL 저장소의 모인 쿼리들을 데이터베이스에 보낸다. 마지막으로 실제 데이터베이스 트랜잭션이 커밋된다. 1차 캐시에 엔티티 저장 Insert Query 생성 후 쓰기지연 SQL 저장소에 쿼리 저장 트랜잭션 커밋 시 쓰기지연 SQL 저장소에 저장된 쿼리들을 데이터베이스로 전송 데이터베이스 트랜잭션 커밋변경감지JPA에서는 변경감지(dirty checking) 기능을 제공하고 이를 통해 엔티티의 값을 변경할 수 있다.EntityManager em = emf.createEntityManager();EntityTransaction transaction = em.getTransaction();transaction.begin() // 트랜잭션 시작// 영속 엔티티 조회Member memberA = em.find(Member.class, &quot;memberA&quot;);// 영속 엔티티 데이터 수정memberA.setUsername(&quot;hi&quot;);memberA.setAge(10);transaction.commit(); // 트랜잭션 커밋변경감지(dirty checking)는 위의 코드와 같이 영속상태의 엔티티를 조회 후 setter를 통해 값을 변경하면 트랜잭션이 커밋될 때변경사항을 데이터 베이스에 자동으로 반영하는 기능이다.JPA 영속성 컨텍스트 내부에 엔티티의 최초 상태를 복사하여 저장해두는데 이를 스냅샷이라 한다.트랜잭션이 커밋되면 스냅샷과 엔티티의 값을 비교하여 데이터 베이스에 변경사항을 반영한다.참고 인프런 자바 ORM 표준 JPA 프로그래밍 - 기본편(김영한) 자바 ORM 표준 JPA 프로그래밍" }, { "title": "엔티티 생명주기(Entity LifeCycle)", "url": "/posts/jpa-02/", "categories": "JPA", "tags": "JPA, Entity LifeCycle", "date": "2022-05-21 00:00:00 +0900", "snippet": "엔티티 생명주기(Entity LifeCycle) 비영속 (new/transient) 영속 (managed) 준영속 (detached) 삭제 (removed)비영속 (new/transient)순수한 객체 상태이며, 영속성 컨텍스트와 관련이 없는 상태Member member = new Member();영속 (managed)EntityManager를 통해 영속성 컨텍스트에 저장되어 관리되는 상태Member member = new Member();entityManager.persist(member);준영속 (detached)영속성 컨텍스트에 저장되었다가 분리된 상태Member member = new Member();entityManager.persist(member); // 영속 상태entityManager.detach(member); // 준영속 상태삭제 (removed)엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한 상태entityManager.remove(member);참고 인프런 자바 ORM 표준 JPA 프로그래밍 - 기본편(김영한) 자바 ORM 표준 JPA 프로그래밍" }, { "title": "JPA 영속성 컨텍스트", "url": "/posts/jpa-01/", "categories": "JPA", "tags": "JPA", "date": "2022-05-20 00:00:00 +0900", "snippet": "영속성(Persistence)JPA의 영속성 컨텍스트에 대해 알아보기 전 우선 영속성이라는 단어부터 알아보자.컴퓨터 공학에서 지속성(Persistence)은 프로세스가 생성했지만 별개로 유지되는 상태의 특징 중 한 가지이며,별도의 기억 장치에 데이터를 보존하는 것을 목적으로 한다. [위키백과]한마디로 DB와 같은 별도의 저장소에 데이터를 영구적으로 저장하는 것을 말한다.영속성 컨텍스트(Persistence Context)JPA에서 영속성 컨텍스트는 가장 중요한 개념 중 하나로 자주 언급될 것이다. JPA에서는 Entity라는 특별한 객체를 관리하는데영속성 컨텍스트란 이러한 엔티티를 영구 저장하는 환경을 의미한다.Entity는 JPA에서 관리하는 특별한 객체를 말한다. Entity는 하나의 테이블에 대응되도록 설계되고JPA는 Entity를 통해 DB에서 데이터를 조회, 저장, 수정, 삭제한다.그리고 이러한 Entity 객체들을 관리하는 역할을 하는 것이 &#39;EntityManager&#39; 이다.EntityManager와 영속성 컨텍스트EntityManager는 위에서 언급하였듯 Entity 객체들을 관리하는 역할을 한다. JPA에서는 EntityManager를 통해 Entity들을 영속성 컨텍스트에 저장한다.그리고 이렇게 영속성 컨텍스트에 저장 된 Entity는 영속성 컨텍스트에 관리되는 상태가 된다.(영속상태-managed)(영속성 컨텍스트는 논리적인 개념으로 EntityManager를 통해 영속성 컨텍스트에 접근한다.)EntityManager.persist(entity); //EntityManager를 통해 entity를 영속성 컨텍스트에 저장JPA는 영속성 컨텍스트가 관리하는 영속상태의 Entity들을 DB에 반영하여 데이터를 저장, 수정, 삭제 한다.참고 인프런 자바 ORM 표준 JPA 프로그래밍 - 기본편(김영한) 자바 ORM 표준 JPA 프로그래밍 위키백과 영속성 위키백과 JPA" }, { "title": "HTTP 요청 파라미터", "url": "/posts/spring-18/", "categories": "Spring", "tags": "Srping, MVC", "date": "2022-05-18 00:00:00 +0900", "snippet": "HTTP 요청 데이터HTTP 요청 메시지를 통해 클라이언트에서 서버로 데이터를 전달하는 다양한 방법이 있다. 그 중 아래의 3가지 방식이 주로 사용된다. GET - 쿼리 파라미터 POST - HTML Form HTTP message BodyGET - 쿼리 파라미터클라이언트에서 서버로 데이터를 전달하는 방법중의 하나는 Url 주소에 파라미터를 명시하여 전달하는 방법이 있다.예) http://localhost/member?memberId=admin&amp;amp;memberNm=관리자?memberId=admin&amp;amp;memberNm=관리자와 같이 물음표 뒤에 연결된 key와 value를 쿼리 파라미터라고 한다.주로 검색, 필터, 페이징에서 많이 사용되는 방식이다.전달 데이터 memberId = admin memberNm = 관리자서버에서는 HttpServletRequest가 제공하는 메서드들을 통해 쿼리 파라미터를 편리하게 조회할 수 있다.String memberId = request.getParameter(&quot;memberId&quot;); //단일 파라미터 조회(memberId 조회)Enumeration&amp;lt;String&amp;gt; parameterNames = request.getParameterNames(); //파라미터 이름들 모두 조회Map&amp;lt;String, String[]&amp;gt; parameterMap = request.getParameterMap(); //파라미터를 Map으로 조회String[] memberIds = request.getParameterValues(&quot;memberId&quot;); //복수 파라미터 조회POST - HTML FormHTML의 Form을 활용하여 Url이 아닌 Message Body에 쿼리 파라미터 형식으로 전달하는 방식이다.application/x-www-form-urlencoded 형식은 Url이 아닌 Message Body를 사용할 뿐 쿼리 파라미터의 형식은 동일하다.이 방식 또한 GET의 쿼리파라미터 조회 메서드를 그대로 사용하면 된다.HTTP message Body이 방식은 HTTP Message body에 데이터를 직접 담아서 요청하는 방식으로 HTTP API (JSON, XML, TEXT)에서 주로 사용되는 방식이다.사용하는 데이터 형식에서 차이가 있기 때문에 서버에서 조회할 때는 위의 두 방식과는 다른 방식으로 조회를 해야한다.(HttpServletRequest의 inputStream을 사용하여 HTTP 메시지 바디의 데이터를 직접 읽을 수 있다.)ServletInputStream inputStream = request.getInputStream();String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);Spring Annotation스프링은 HTTP 요청 파라미터를 편리하게 조회할 수 있는 다양한 어노테이션을 지원한다.@RequestParam@RequestParam 어노테이션은 Get과 Form 방식에서 사용된 쿼리 파라미터를 편리하게 조회할 수 있도록 지원한다.?memberId=admin&amp;amp;memberNm=관리자에서 memberId를 조회하기 위해 request.getParameter(&quot;memberId&quot;)와 같은 방식을 사용하였다.이는 어노테이션을 활용하여 아래와 같이 작성할 수 있다.@PostMapping(&quot;/save&quot;)public String save(@RequestParam(&quot;memberId&quot;) String memberId, @RequestParam(&quot;memberNm&quot;) String memberNm) { Member member = new Member(memberId, memberNm); ...}@ModelAttribute@RequestParam 어노테이션을 활용하면 편리하게 요청 파라미터를 받을 수 있다. 위의 예제를 보면 요청 파라미터를 받아새로운 객체를 만드는 것을 볼 수 있다. 실무에서는 이렇게 요청 파라미터를 통해 새로운 객체를 만들어야 하는 경우가 빈번하다.@ModelAttribute는 이러한 과정을 자동화 해준다. 아래의 코드는 @RequestParam의 예제와 동일하게 동작한다.@PostMapping(&quot;/save&quot;)public String save(@ModelAttribute Member member) { System.out.println(member.getMemberId()); //admin System.out.println(member.getMemberNm()); //관리자 ...}@RequestBody@RequestBody를 사용하면 HTTP 메시지 바디 정보를 편리하게 조회할 수 있다. 이는 위의 RequestParam과 @ModelAttribute와 같이요청 파라미터를 조회하는 방식과는 차이가 있다. 주로 JSON 형식의 데이터를 처리할 때 사용한다. 요청 파라미터 조회: @RequestParam, @ModelAttribute HTTP 메시지 바디 직접 조회: @RequestBody참고 인프런 스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술(김영한) 토비의 스프링" }, { "title": "뷰 리졸버", "url": "/posts/spring-17/", "categories": "Spring", "tags": "Srping, MVC, View, View Resolver", "date": "2022-05-16 00:00:00 +0900", "snippet": "뷰(View)뷰(View)는 MVC 아키텍처에서 모델이 가진 정보를 어떻게 표현해야 하는지에 대한 로직을 갖고 있는 컴포넌트다.웹 환경에서 뷰가 생성하는 결과물은 일반적으로 브라우저에 나타낼 수 있는 HTML이다.스프링은 컨트롤러(핸들러)의 작업을 마친 후 뷰 정보를 ModelAndView 타입 오브젝트에 담아서 DispatcherServlet에돌려 주고 크게 두가지 방법이 있다. View 타입 오브젝트 반환 뷰 이름 반환뷰 리졸버(View Resolver)컨트롤러(핸들러)가 뷰의 이름을 돌려주는 경우는 뷰 이름으로부터 실제 사용할 뷰를 결정해주는 뷰 리졸버(View Resolver)가 필요하다.스프링은 다양한 뷰 리졸버를 제공하고 대표적으로 스프링 부트를 사용할 경우 InternalResourceViewResolver라는 뷰 리졸버를 자동으로 등록하는데,이때 application.properties에 등록한 spring.mvc.view.prefix, spring.mvc.view.suffix 설정정보를 사용해서 등록한다.뷰 리졸버 동작 방식 컨트롤러(핸들러)가 뷰의 이름(논리 뷰 이름)을 반환한다. 획득한 뷰의 이름(논리 뷰 이름)을 통해 스프링에 등록 된 ViewResolver를 순서대로 호출한다. 호출된 ViewResolver를 통해 View 객체를 반환 받는다. 반환 된 View 객체를 통해 view.render()를 호출 한다.참고 인프런 스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술(김영한) 토비의 스프링" }, { "title": "스프링 핸들러 매핑과 핸들러 어댑터", "url": "/posts/spring-16/", "categories": "Spring", "tags": "Srping, MVC, Handler Mapping, Handler Adapter", "date": "2022-04-26 00:00:00 +0900", "snippet": "핸들러 매핑(Handler Mapping)핸들러 매핑(Handler Mapping)은 HTTP 요청정보를 이용하여 이를 처리할 핸들러 오브젝트, 즉 컨트롤러를 찾아주는 기능을 가진 DispatcherServlet의 전략이다.스프링은 기본적으로 다섯 가지 핸들러 매핑을 제공한다. BeanNameUrlHandlerMapping: HTTP 요청 URL과 빈의 이름을 비교하여 일치하는 빈을 찾는다. ControllerBeanNameHandlerMapping: BeanNameUrlHandlerMapping과 유사하지만 위처럼 빈 이름을 URL 형태로 짓지 않아도 된다는 차이가 있다. ControllerClassNameHandlerMapping: 빈의 클래스 이름을 URL에 매핑해주는 매핑 클래스이다. SimpleUrlHandlerMapping: URL과 컨트롤러 매핑정보를 한곳에 모아놓을 수 있는 전략이다. RequestMappingHandlerMapping: @RequestMapping이라는 애노테이션을 이용해 매핑하는 전략이다.DispatcherServlet은 init되는 순간 HandlerMapping 전략들을 등록한다. 스프링 부트의 경우 RequestMappingHandlerMapping 전략이 가장 높은 우선 순위를 가진다.DispatcherServlet은 getHandler 함수를 호출하여 등록된 HandlerMapping전략들의 우선순위 순으로 핸들러를 찾는다.핸들러 어댑터(Handler Adapter)핸들러 어댑터(Handler Adapter)는 핸들러 매핑을 통해 검색된 핸들러 객체를 가지고 이에 맞는 어댑터를 찾는 과정이다.여기서 어댑터란, 2개 이상의 인터페이스에 스펙이 맞지 않을 때, 중간에 이 스펙이 맞도록 변환해주는 역할을 하는 객체이다.실행 흐름실행 흐름은 Handler Mapping을 통해 Handler를 조회하고 이를 실행 시킬 Handler Adapter를 조회한다.이후 조회 된 Handler Adapter를 통해 Handler를 실행한다. Handler Mapping으로 Handler 조회 Handler Adapter 조회 Handler Adapter 실행참고 인프런 스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술(김영한) 토비의 스프링" }, { "title": "Spring MVC 구조", "url": "/posts/spring-15/", "categories": "Spring", "tags": "Srping, MVC", "date": "2022-04-24 00:00:00 +0900", "snippet": "Spring MVC 구조DispatcherServletDispatcherServlet은 지난 포스팅에서 다룬 Front Controller 패턴의 Front Controller에 해당한다.DispatcherServlet은 스프링 MVC의 핵심으로 부모 클래스에서 HttpServlet을 상속 받아 사용하고, 서블릿으로 동작한다.요청 흐림 서블릿이 호출되면 HttpServlet이 제공하는 service()가 호출된다. (스프링 MVC는 DispatcherServlet의 부모인 FrameworkServlet에서 service()를 오버라이드 해두었다) FrameworkServlet.service()를 시작으로 여러 메서드가 호출되면서 DispatcherServlet.doDispatch()가 호출된다. DispatcherServlet.doDispatch()protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throw Exception { HttpServletReqeust processedRequest = request; HandlerExecutionChain mappedHandler = null; ModelAndView mv = null; // 1. 핸들러 조회 mappedHandler = getHandler(processedRequest); if (mappedHandler == null) { noHandlerFound(processedRequest, response); return; } // 2. 핸들러 어댑터 조회 - 핸들러를 처리 할 수 있는 어댑터 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // 3. 핸들러 어댑터 실행 -&amp;gt; 4. 핸들러 어댑터를 통해 핸들러 실행 -&amp;gt; 5. ModelAndView 반환 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);}private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throw Exception { // 뷰 렌더링 호출 render(mv, request, response);}protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throw Exception { View view; String viewName = mv.getViewName(); // 6. 뷰 리졸버를 통해서 뷰 찾기 -&amp;gt; 7. View 반환 view = resolveViewName(viewName, mv.getModelInternal(), locale, request); // 뷰 렌더링 view.render(mv.getModelInternal(), request, response);}동작 순서 핸들러 조회: 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회한다. 핸들러 어댑터 조회: 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다. 핸들러 어댑터 실행: 핸들러 어댑터를 실행한다. 핸들러 실행: 핸들러 어댑터가 실제 핸들러를 실행한다. ModelAndView 반환: 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView로 변환하여 반환한다. ViewResolver 호출: 뷰 리졸버를 찾고 실행한다. View 반환: 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 변경하고, 렌더링 역할을 담당하는 뷰 객체를 반환한다. 뷰 렌더링: 뷰를 통해서 뷰를 렌더링 한다.스프링 MVC의 강점스프링 MVC의 강점은 DispatcherServlet 코드의 변경 없이, 원하는 기능을 변경하거나 확장 할 수 있다는 점이다.대부분의 기능을 확장 가능한 인터페이스로 제공하고 이를 구현하고 DispatcherServlet에 등록하여 변경 또는 확장하여 사용이 가능하다.주요 인터페이스 목록 핸들러 매핑: org.springframework.web.servlet.HandlerMapping 핸들러 어댑터: org.springframework.web.servlet.HandlerAdapter 뷰 리졸버: org.springframework.web.servlet.ViewResolver 뷰: org.springframework.web.servlet.View참고 인프런 스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술(김영한) 토비의 스프링" }, { "title": "Front Controller 패턴", "url": "/posts/spring-14/", "categories": "Spring", "tags": "Srping, MVC, Front Controller", "date": "2022-04-17 00:00:00 +0900", "snippet": "Front Controller 패턴이전 포스팅에서 다루었던 MVC 패턴을 적용하면 컨트롤러의 역할과 뷰를 렌더링 하는 역할을 명확하게 구분할 수 있었다.하지만 컨트롤러에서 뷰를 호출하기 위한 중복코드들과 공통 로직을 처리하기 어려운 문제점이 있었다.Front Controller 패턴은 개별 컨트롤러가 요청을 받는 MVC 패턴과 달리 하나의 서블릿이 클라이언트 요청을 받도록 하였다.한마디로 각각의 컨트롤러 앞에 입구가 생긴 것이다. 서블릿 하나로 클라이언트의 요청을 받음 Front Controller가 요청에 맞는 Controller 를 찾아서 호출 Front Controller를 제외한 나머지 Controller는 서블릿을 사용하지 않아도 됨스프링 웹 MVC도 Front Controller 패턴으로 설계가 되어있고 Front Controller 역할을 하는 것이 DispatcherServlet 이다참고 인프런 스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술(김영한) 토비의 스프링" }, { "title": "MVC 패턴", "url": "/posts/spring-13/", "categories": "Spring", "tags": "Srping, MVC", "date": "2022-04-10 00:00:00 +0900", "snippet": "MVC 패턴(Model View Controller)MVC는 Model, View, Controller의 약자로 하나의 애플리케이션을 구성할 때 그 구성요소를 세가지의 역할로 구분한 패턴이다.MVC 패턴 이전에는 비즈니스 로직과 뷰 로직 등 애플리케이션 구성요소들이 하나로 구성된 경우가 많았다. 이 경우 장점도 있겠지만많은 단점들이 생겨난다. 너무 많은 역할 예를 들어 하나의 서블릿이나 JSP만으로 비즈니스 로직과 뷰 렌더링까지 모두 처리할 경우, 화면 변경이 필요한 경우에 비즈니스 로직을 변경해야 할 경우가 발생될 수 있다. 너무 많은 역할을 하게 될 경우 유지보수 시 변경의 이유 또한 많아진다. 이로 인해 유지보수성이 떨어지게 되므로 역할을 나누는 것이 좋다. 변경의 라이프 사이클 중요한 문제는 비즈니스 로직과 뷰로직은 서로 변경의 라이프 사이클이 다르다는 점이다. UI를 일부 수정하는 일과 비즈니스 로직을 수정하는 일을 각각 다르게 발생할 가능성이 매우 높고 대부분 서로에게 영향을 주지 않는다. 기능 특화 특히 JSP 같은 뷰 템플릿은 화면을 렌더링 하는데 최적화 되어 있기 때문에 이 부분의 업무만 담당하는 것이 가장 효과적이다. Controller: HTTP 요청을 받아서 파라미터를 검증하고, 비즈니스 로직을 실행한다. 그리고 뷰에 전달할 결과 데이터를 조회해서 모델에 담는다. Model: 뷰에 출력할 데이터를 담아둔다. View: 모델에 담겨있는 데이터를 사용하여 화면을 그리는 일을 담당한다. HTML을 생성하는 부분을 말한다.MVC 패턴의 한계MVC 패턴을 적용하면 컨트롤러의 역할과 뷰를 렌더링 하는 역할을 명확하게 구분할 수 있다.하지만 컨트롤러에서 뷰를 호출하기 위한 중복코드들이 존재하게 된다.포워드 중복View로 이동하는 코드가 항상 중복 호출되어야 한다.ReqeustDispatcher dispatcher = request.getReqeustDispatcher(viewPath);dispatcher.forward(request, response);ViewPath 중복String viewPath = &quot;/WEB-INF/views/new-form.jsp&quot;;공통처리가 어렵다예를 들어 모든 컨트롤러 실행 전이나 후에 처리할 공통기능을 개발하려 한다면 MVC 구조에서는 모든 컨터롤러에 중복 로직을 작성해야한다.이 문제를 해결하기 위해서는 모든 컨트롤러 실행전 공통기능을 처리해 줄 무언가가 필요해진다.이러한 문제는 프론트 컨트롤러(Front Controller)패턴을 도입하면 해결할 수 있다스프링 또한 프론트 컨트롤러 패턴으로 설계되어 있고 프론트 컨트롤러 패턴은 다음 포스팅에서 다루겠다.참고 인프런 스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술(김영한) 토비의 스프링" }, { "title": "쿠키", "url": "/posts/http-12/", "categories": "HTTP", "tags": "HTTP, 쿠키, Cookie", "date": "2022-04-02 00:00:00 +0900", "snippet": "쿠키HTTP 쿠키는 웹쿠키, 브라우저 쿠키로도 불리며 사용자 웹 브라우저에 저장되는 작은 데이터 파일이다.쿠키에는 이름, 값, 만료 날짜, 경로 정보가 들어있다.쿠키는 Response Header의 Set-Cookie을 사용하여 클라이언트에 쿠키 정보를 저장할 수 있다.그리고 이렇게 만들어진 쿠키는 클라이언트가 요청 시 마다 Request Header에 포함하여 서버에 전송한다. 예 set-cookie: sessionId=abcde1234; expires=Sat, 26-Dec-2020 00:00:00 GMT; path=/; domain=.google.com; Secure 사용처 사용자 로그인 세션 관리 광고 정보 트래킹 쿠키 정보는 항상 서버에 전송된다. 네트워크 트래픽 추가 유발 최소한의 정보만 사용(세션 id, 인증토큰) 보안에 민감한 데이터는 저장하면 안된다.(주민등록번호, 신용카드 번호, 비밀번호 등)생명주기쿠키는 Expires와 max-age 속성을 활용하여 생명주기를 설정할 수 있다. 예 expires=Sat, 26-Dec-2020 04:39:21 GMT (만료일이 되면 쿠키 삭제) max-age=3600(3600초 - 0이나 음수를 지정하면 쿠키 삭제) 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료 시 까지만 유지 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지도메인도메인은 쿠키가 전송되게 될 호스트들을 명시한다. 예 domain=example.org 명시: 명시한 문서 기준 도메인 + 서브 도메인 포함 domain=example.org를 지정해서 쿠키를 생성(example.org는 물론이고 dev.example.org도 쿠키 접근) 생략: 현재 문서 기준 도메인만 적용 example.org에서 쿠키를 생성하고 domain 지정을 생략(example.com에서만 쿠키 접근, dev.example.org는 쿠키 미접근) 경로경로는 Cookie 헤더를 전송하기 위하여 요청되는 URL 내에 반드시 존재해야 하는 URL 경로입니다. 예 path=/home (이 경로를 포함한 하위 경로 페이지만 쿠키 접근) 일반적으로 path=/(루트)로 지정 path=/home 지정 시 /home -&amp;gt; 가능 /home/level1 -&amp;gt; 가능 /home/level1/level2 -&amp;gt; 가능 /hello -&amp;gt; 불가능 보안 Secure 쿠키는 http, https를 구분하지 않고 전송 Secure를 적용하면 https인 경우에만 전송 HttpOnly XSS 공격 방지 자바스크립트에서 접근 불가(document.cookie) HTTP 전송에만 사용 SameSite XSRF 공격 방지 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송 참고 인프런 모든 개발자를 위한 HTTP 웹 기본 지식(김영한)" }, { "title": "컨텐츠 협상(Content negotiation)", "url": "/posts/http-11/", "categories": "HTTP", "tags": "HTTP, Content negotiation", "date": "2022-03-22 00:00:00 +0900", "snippet": "컨텐츠 협상(Content negotiation)컨텐츠 협상이란 클라이언트가 URI로 특정 리소스를 요청할 때 서버가 클라이언트에게 가장 적절한프로젠테이션을 제공할 수 있도록 정보를 명시하는 것을 말한다. (예를들어, 언어나 이미지 포맷 혹은 컨텐츠 인코딩)서버 주도 컨텐츠 협상서버 주도 컨텐츠 협상은 브라우저가 서버에 HTTP 헤더를 전송하고 이를 통해 컨텐츠를 선택하는 것을 말한다. Accept: 클라이언트가 선호하는 미디어 타입 전달 Accept-Charset: 클라이언트가 선호하는 문자 인코딩 Accept-Encoding: 클라이언트가 선호하는 압축 인코딩 Accept-Language: 클라이언트가 선호하는 자연 언어협상과 우선순위HTTP 헤더가 제시하는 속성이 여러 개일 경우 인자 가중치(q: Quality value)를 함께 전달 할 수 있다.그리고 이 인자 가중치를 활용하여 우선순위를 판별한다. 0 ~ 1의 값을 가지고 클수록 우선순위가 높음 값이 생략되면 1을 가짐 예) Accept-Language: ko-KR,ko;q=0.9,en-US;q-0.8,en;q=0.7 ko-KR; (값이 생략되어 q=1로 우선순위가 가장 높음) ko;q=0.9 en-US;q=0.8 en;q=0.7 참고 인프런 모든 개발자를 위한 HTTP 웹 기본 지식(김영한) Content negotiation(mdn web docs)" }, { "title": "HTTP 헤더 개요", "url": "/posts/http-10/", "categories": "HTTP", "tags": "HTTP, HTTP 헤더", "date": "2022-03-21 00:00:00 +0900", "snippet": "HTTP 헤더HTTP 헤더는 클라이언트와 서버가 요청 또는 응답으로 부가적인 정보를 전송할 수 있도록 해준다.HTTP 헤더는 대소문자를 구분하지 않는 이름과 콜론 &#39;:&#39; 다음에 오는 값(줄 바꿈 없이)으로 이루어져 있다. header-field = field-name: OWS field-value OWS (OWS: 띄어쓰기 허용)표현2014년 RFC7230 ~ 7235 등장하며 기존 RFC2616 폐기되고 RFC2616의 엔티티(Entity)가 표현(Representation)으로 대체되었다. 표현(Representation) = 표현 메타데이터(Representation Metadata) + 표현 데이터(Representation Data) Content-Type: 표현 데이터의 형식 Content-Encoding: 표현 데이터의 압축 방식 Content-Language: 표현 데이터의 자연 언어 Content-Length: 표현 데이터의 길이Content-Type - 표현 데이터의 형식Content-Type 개체 헤더는 리소스의 Media Type을 나타내기 위해 사용된다. 예) text/html; charset=utf-8 application/json image/png Content-Encoding - 표현 데이터의 압축 방식Content-Encoding 개체 해더는 미디어 타입을 압축하기 위해 사용된다.이 헤더가 존재하면, 그 값은 개체 본문에 어떤 추가적인 컨텐츠 인코딩이 적용될지를 나타낸다. 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가 데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축 해제 예) gzip deflate identity Content-Language - 표현 데이터의 자연 언어Content-Language 개체 해더는 표현 데이터의 자연 언어를 표현한다. 예) ko en en-US Content-Length - 표현 데이터의 길이Content-Length 개체 해더는 수신자에게 보내지는, 바이트 단위를 가지는 개체 본문의 크기를 나타낸다. Transfer-Encoding(전송 코딩)을 사용하면 Content-Length를 사용하면 안됨참고 인프런 모든 개발자를 위한 HTTP 웹 기본 지식(김영한) HTTP 헤더(mdn web docs) Content-Type(mdn web docs) Content-Encoding(mdn web docs) Content-Language(mdn web docs) Content-Length(mdn web docs)" }, { "title": "HTTP 상태코드", "url": "/posts/http-09/", "categories": "HTTP", "tags": "HTTP, HTTP 상태코드", "date": "2022-03-04 00:00:00 +0900", "snippet": "HTTP 상태코드HTTP 상태코드는 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능으로 5개의 클래스(분류)로 구분된다. 1xx(정보): 요청을 받았으며 프로세스를 계속한다 2xx(성공): 요청을 성공적으로 받았으며 인식했고 수용하였다 3xx(리다이렉션): 요청 완료를 위해 추가 작업 조치가 필요하다 4xx(클라이언트 오류): 요청의 문법이 잘못되었거나 요청을 처리할 수 없다 5xx(서버 오류): 서버가 명백히 유효한 요청에 대해 충족을 실패했다2xx클라이언트가 요청한 동작을 수신하여 이해했고 승낙했으며 성공적으로 처리했음을 가리킨다. 200(성공): 서버가 요청을 제대로 처리함 201(작성됨): 성공적으로 요청되었으며 서버가 새 리소스를 작성 202(허용됨): 서버가 요청을 접수했지만 아직 처리하지 않음 배치 처리 같은 곳에서 사용 204(콘텐츠 없음): 서버가 요청을 성공적으로 처리했지만 콘텐츠를 제공하지 않음 예시: 웹 문서 편집기에서 save 버튼을 누렀을 경우, 결과로 아무 내용이 없어도 된다. 3xx클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다. 300(여러 선택항목): 서버가 요청에 따라 여러 조치를 선택할 수 있음 301(영구 이동): 요청한 페이지를 새 위치로 영구적으로 이동 페이지가 영구적으로 변경된 경우, 301과 308은 검색 엔진 등에서도 변경 인지 301은 리다이렉트 시 요청 메서드가 GET으로 변하고, 분문이 제거 될 수 있다, 308은 301과 기능은 같지만 처음 요청 그대로 요청을 보내고 본문을 유지한다. 302(임시 이동): 현재 서버가 다른 위치의 페이지로 요청에 응답하고 있지만 요청자는 향후 요청 시 원래 위치를 계속 사용 리다이렉트 시 요청 메서드가 GET으로 변하고, 본문이 제거 될 수 있음 307은 302와 기능은 같지만 요청 메서드와 본문을 유지한다 303(기타 위치 보기): 요청자가 다른 위치에 별도의 GET 요청을 하여 응답을 검색할 경우 서버는 이 코드를 표시 302와 기능이 같고 리다이렉트 시 요청 메서드가 GET으로 변경(302도 대부분 GET으로 변경된다) 304(수정되지 않음): 마지막 요청 이후 요청한 페이지는 수정되지 않음 캐시를 목적으로 사용 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용 한다. 304 응답은 응답에 메시지 바디를 포함하면 안된다. 조건부 GET, HEAD 요청 시 사용 4xx클라이언트에 오류가 있음을 나타낸다. 400(잘못된 요청): 서버가 요청의 구문을 인식하지 못함 요청 구문, 메시지 등의 오류 요청 파라미터가 잘못되거나, API 스펙이 맞지 않을 때 401(권한 없음): 인증이 필요함 401 오류 발생 시 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명 403(Forbidden, 금지됨): 서버가 요청을 이해했지만 승인을 거부함 주로 인증 자격 증명은 있지만, 접근 권한이 불충분한 경우 404(Not Found, 찾을 수 없음): 서버가 요청한 페이지를 찾을 수 없음 요청 리소스가 서버에 없거나 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기기 위해 사용 5xx서버가 유효한 요청을 명백하게 수행하지 못함(서버 오류) 500(내부 서버 오류): 서버에 오류가 발생하여 요청을 수행할 수 없다 503(서비스를 사용할 수 없음): 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음 Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼 수도 있음 참고 인프런 모든 개발자를 위한 HTTP 웹 기본 지식(김영한) 위키백과" }, { "title": "HTTP 메서드", "url": "/posts/http-08/", "categories": "HTTP", "tags": "HTTP, HTTP 메서드", "date": "2022-02-26 00:00:00 +0900", "snippet": "HTTP 메서드HTTP는 요청 메서드라는 것을 통해 주어진 리소스에 수행하길 원하는 행동을 나타낸다.HTTP 메서드 종류 GET: 리소스 조회 POST: 요청 데이터 처리, 주로 등록에 사용 PUT: 리소스 대체, 해당 리소스가 없으면 생성 PATCH: 리소스 부분 변경 DELETE: 리소스 삭제 HEAD: GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환 CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정 OPTIONS: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용) TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행(GET, POST, PUT, PATCH, DELETE가 주로 사용된다.)GET 주로 데이터를 읽거나 검색할 때 사용 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음POST 주로 새로운 리소스를 생성할 때 사용 메시지 바디를 통해 서버로 요청 데이터 전달POST는 주로 새로운 리소스 생성에 사용한다고 하였지만 그 외에도 다양한 곳에 사용된다. 그렇기 때문에 POST는 정해진 것 없이 요청 데이터를 어떻게처리할지 리소스마다 따로 정의하는 것이 좋다. 사용 예시 새로운 리소스 생성 요청 데이터 처리 (주문에서 결제완료로 상태 변경과 같은 프로세스 처리가 필요한 경우) 다른 메서드로 처리하기 애매한 경우 PUT 리소스를 생성 / 업데이트하기 위해 사용 리소스가 있으면 대체, 없으면 생성 POST와 차이점은 PUT은 클라이언트가 리소스 위치를 알고 URI를 지정(클라이언트가 리소스를 식별)PATCH 리소스 부분 변경DELETE 리소스 제거참고 인프런 모든 개발자를 위한 HTTP 웹 기본 지식(김영한) MDN Web Docs" }, { "title": "HTTP 메시지", "url": "/posts/http-07/", "categories": "HTTP", "tags": "HTTP, HTTP 메시지", "date": "2022-02-26 00:00:00 +0900", "snippet": "HTTP 메시지HTTP 메시지는 서버와 클라이언트 간에 데이터가 교환되는 방식으로 요청(Request)과 응답(Response) 두가지 타입이 있다.요청은 클라이언트가 서버로 전달하는 것이고 응답은 요청에 대한 서버의 답변이다.HTTP 메시지는 ASCII로 인코딩된 텍스트 정보이며 구조는 다음과 같다.요청 메시지와 응답 메시지는 start-line이 다를 뿐 유사한 구조를 가지고 있고 이들은 크게 HTTP Head와 HTTP Body로 구분할 수 있다. HTTP Head: start-line + HTTP headers HTTP Body: bodystart-linestart-line에는 시행되어야 할 요청, 또는 요청 수행에 대한 성공 또는 실패가 기록되어 있고 항상 한 줄로 끝난다. 요청: HTTP Method + Reqeust Target + HTTP Version (예 GET /test.html?query=alibaba HTTP/1.1) 응답: HTTP Version + Status Code + Status Text (예 HTTP/1.1 404 Not Found.) HeaderHTTP 전송에 필요한 모든 부가정보(메타정보)가 포함되고 header-filed는 field-name과 field-value로 구성되어 있고 field-name은 대소문자를 구분하지 않는다. header-field: field-name: OWS field-value OWS (OWS: 띄어쓰기 허용) (예: Host: www.google.com) Body실제 전송할 데이터가 포함되고 HTML 문서, 이미지 영상, JSON등 byte로 표현할 수 있는 모든 데이터를 포함하여 전송할 수 있다.참고 인프런 모든 개발자를 위한 HTTP 웹 기본 지식(김영한) MDN Web Docs" }, { "title": "URI와 URL 그리고 URN", "url": "/posts/http-06/", "categories": "HTTP", "tags": "HTTP, URI, URL, URN", "date": "2022-02-21 00:00:00 +0900", "snippet": "URI(Uniform Resource Identifier)우리는 인터넷상에 수많은 데이터 자원을 검색한다. 네이버나 구글에서 단어를 검색하거나 유튜브에서 내가 좋아하는 유튜버의 영상을 찾아 볼수도 있다.또는 음악을 찾아 들어볼 수도 있다.그런데 여기서 우리는 어떻게 그 수많은 영상과 음악들을 식별할 수 있을까? 다시말해 유튜브 서버에 접속 한뒤 수많은 영상중 내가 원하는 영상은 어떻게 찾을 수 있을까?결론부터 말하면 이때 사용하는 것이 URI 이다. URI는 인터넷에서 자원을 식별하기 위한 식별자를 말한다. 그리고 URI는 locator, name 또는 둘다 추가로 분류 될 수 있다.자원의 식별우리는 서로 다른 것을 구분하고 식별하기 위해 어떤 수단을 사용한다. 그리고 이런 수단을 식별자라 부른다.이름 (Name)세상에는 수많은 사람들이 존재한다. 과연 그들과 나를 어떻게 구분할 수 있을까?우리는 모두 자신의 이름을 가지고 있다. 그리고 우리는 이름을 통해 서로를 구분하여 부른다.(물론 이름이 같은 사람도 있지만 중요한 것은 이름으로 우리는 서로를 구분하고 식별한다는 사실이다.)주소 (위치 - Locator)다른 예시를 들어보면 우리는 집마다 주소를 부여하고 이러한 주소로 집들을 구분한다. 그렇기 때문에 수많은 집들 중 내집을 식별할 수 있는 것이다.URL과 URN정리해보면 인터넷 상에서 수많은 데이터를 식별하기 위해서 이름이나 위치를 통해 자원을 식별한다. 그리고 이러한 식별 주소를URL(Uniform Resource Locator)과 URN(Uniform Resource Name)이라 한다. URL: 리소스가 있는 위치를 지정 URN: 리소스에 이름을 부여크게 두가지 방법으로 자원을 식별하는데 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않아 URN은 잘 사용하지 않는다.현재는 대부분 URL을 사용하고 있으므로 URL과 URI를 같은 의미로 사용하는 경우가 많다.URL 전체 문법scheme://[userinfo@]host[:port][/path][?query][#fragment]예시https://www.google.com:443/search?q=hello&amp;amp;hl=ko 프로토콜: https 호스트명: www.google.com 포트번호: 443 경로: /search 쿼리 파라미터: q=hello&amp;amp;hl=ko scheme: 주로 프로토콜 사용 userinfo: URL에 사용자 정보를 포함해서 인증, 거의 사용하지 않음 host: 도메인명 또는 IP 주소 사용 host: 도메인명 또는 IP 주소 사용 port: 접속 포트 정보, 일반적으로 생략하고 생략 시 http는 80, https는 443 port를 사용 path: 리소스 경로, 계층적 구조 query: key=value의 형태로 ?로 시작하고, &amp;amp;로 추가한다. fragment: html 내부 북마크 등에 사용하고 서버로 전송하는 정보가 아님참고 인프런 모든 개발자를 위한 HTTP 웹 기본 지식(김영한) 위키백과 DNS" }, { "title": "DNS", "url": "/posts/http-05/", "categories": "HTTP", "tags": "HTTP, DNS", "date": "2022-02-21 00:00:00 +0900", "snippet": "DNS우리가 인터넷을 통해 서버와 통신하기 위해서는 서버의 IP 주소를 알고 있어야 한다. 만약 우리가 네이버나 구글 사이트를 접속하고자 한다면우리는 각 서버의 IP 주소를 알고 있어야한다. 문제는 IP주소는 외우기 힘들다는 것과 변경이 될 수 있다는 점이다.우리가 친구에게 전화 걸때를 생각해보면 번호를 직접 입력하지 않고 주소록에 있는 친구 이름을 검색할 것이다.왜나면 번호를 외우기도 힘들고 친구가 기기를 변경하면서 번호가 바뀔수도 있기 때문이다.이처럼 IP 주소도 이름으로 관리 해주는 일종의 주소록이 존재하는데 이를 DNS(Domain Name System)라 한다.이러한 DNS가 있기 때문에 우리가 평소 네이버나 구글을 검색할때 IP주소가 아닌 www.naver.com이나 www.google.com과 같은도메인 이름을 통해 서버에 접속을 할 수 있는 것이다.참고 인프런 모든 개발자를 위한 HTTP 웹 기본 지식(김영한) 위키백과 DNS" }, { "title": "PORT", "url": "/posts/http-04/", "categories": "HTTP", "tags": "HTTP, PORT", "date": "2022-02-21 00:00:00 +0900", "snippet": "PORT인터넷 프로토콜에서 PORT가 하는 역할을 알아보자. 만약 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상인 경우는 어떻게 될까?이 경우 IP 프로토콜은 둘을 구분할 방법이 없다. 이런 IP 프로토콜의 한계로 인해 우리는 TCP 프로토콜을 추가로 사용한다.그리고 그림과 같이 애플리케이션을 구분하기 위해 사용하는 것이 PORT 이다.TCP/IP 패킷에는 IP정보 뿐만 아니라 출발지 PORT와 도착지 PORT 정보가 있다. PORT 정보를 통해 서버에서는 통신하는 프로세스를 구분할 수 있다.(IP는 아파트의 주소이고 Port는 동호수에 해당한다)Well-Known Port포트는 0 ~ 65535까지 할당할 수 있지만 잘 알려진 Port들이 있다. 이러한 Port는 사용하지 않는 것이 좋다. 0 ~ 1023: 잘 알려진 포트, 사용하지 않는 것이 좋음 FTP - 20, 21 SSH - 22 TELNET - 23 SMTP - 25 DNS - 53 HTTP - 80 NTP - 123 HTTPS - 443 Syslog - 514 참고 인프런 모든 개발자를 위한 HTTP 웹 기본 지식(김영한) 위키백과 PORT" }, { "title": "TCP 프로토콜", "url": "/posts/http-03/", "categories": "HTTP", "tags": "HTTP, TCP", "date": "2022-02-16 00:00:00 +0900", "snippet": "인터넷 프로토콜 스택의 4계층이번 포스팅에서는 TCP 프로토콜에 대해 알아보려 한다. 인터넷에서 컴퓨터들이 서로 통신을 하는데 있어서 여러 프로토콜이 있다.그 중 대표적인 프로토콜이 이전 포스팅에서 다룬 IP 프로토콜이다.그리고 이러한 수많은 프로토콜이 모여 통신을 하게 되고 이들은 용도에 따라 서로 계층 관계로 이루어져 있다.계층은 그림에서 처럼 크게 4계층으로 나눌 수 있다. 애플리케이션 계층 전송 계층 인터넷 계층 네트워크 인터페이스 계층전송을 할때는 위에서 아래로 내려가고 수신의 경우 위로 올라간다.하나씩 알아보면 우선 애플리케이션 계층에는 웹 브라우저나 채팅 프로그램, 네트워크 게임등과 같이 인터넷을 통해 정보를 주고 받을 수 있는프로그램이 있다. 이러한 프로그램들은 Socket 라이브러리를 통해 OS계층에 메시지를 전달한다.그 다음 OS는 전달받은 정보를 TCP 프로토콜을 활용하여 TCP 정보를 생성한다. 그리고 TCP 정보를 IP 프로토콜을 통해 IP 패킷으로 생성한다.그리고 이렇게 생성된 IP 패킷을 네트워크 인터페이스 계층에서 LAN 카드를 통해 인터넷 상으로 전송한다. (수신은 위의 과정이 역순으로 이루어진다.)IP 패킷 정보IP 프로토콜은 같은 IP 주소를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상인 경우는 구분이 불가능 했다. 그래서 TCP 프로토콜을 활용하여 추가 정보를 넣어준다.TCP 프로토콜 특징TCP(Transmission Control Protocol) 프로토콜은 전송 제어 프로토콜로 이름 그래도 전송을 제어하는 기능을 담당한다. TCP는 크게 3가지 특징이 있다. 연결지향 - TCP 3 Way Handshake(가상 연결) 데이터 전달 보증 순서 보장TCP 3 Way HandshakeTCP 3 Way Handshake는 TCP/IP 프로토콜을 이용해 통신하는 응용프로그램이 보내는 데이터의 정확한 전송을 보장하기 위해 사전에 세션을 수립하는 과정을 의미한다. 클라이언트에서 서버로 SYN 메시지를 보낸다. 서버가 SYN를 받으면 클라이언트에게 ACK 메시지를 보낸다. 클라이언트가 ACK 메시지를 받으면 다시 서버로 ACK 메시지를 보낸다. 이후 연결이 됬다고 판단하고 데이터를 전송한다. (통신이 가능한 상태를 말한다. 실제 물리적 연결이 이루어지지 않는다.)데이터 전달 보증데이터 전달 보증은 클라이언트가 서버로 데이터를 보내면 서버가 데이터를 수신했음을 클라이언트에게 알려준다. 이를통해 데이터가 전달 됬음을 알 수 있다.순서 보장순서보장은 서버가 데이터를 수신하였는데 1번 패킷 다음 2번이 아닌 3번 패킷이 도착 하였다면 3번 패킷부터 이후 패킷을 모두 버리고2번 패킷부터 다시 요청한다. 이를 통해 순서가 보장될 수 있다.참고 인프런 모든 개발자를 위한 HTTP 웹 기본 지식(김영한) 위키백과 인터넷 전송 제어 프로토콜" }, { "title": "IP(인터넷 프로토콜)", "url": "/posts/http-02/", "categories": "HTTP", "tags": "HTTP, IP", "date": "2022-02-14 00:00:00 +0900", "snippet": "인터넷 프로토콜우리는 인터넷을 사용 하면서 한번쯤 IP주소에 대해 들어보았을 것이다.자세히는 몰라도 인터넷을 사용하기 위해서는 IP 주소가 필요하다는 것은 알고있을 것이다. 그렇다면 IP주소는 무엇이고 왜 사용되는지 알아보자.위의 그림을 보면 클라이언트와 서버가 등장한다. 클라이언트는 웹 브라우저(익스플로러, 크롬등)를 사용하는 우리를 생각하면 되고서버는 구글 또는 네이버 사이트를 생각해보면 이해가 쉬울 것이다.네이버에서 웹툰을 보려 한다고 가정해보자. 그렇다면 우리는 웹브라우저를 실행시키고 네이버 웹툰 사이트에 접속할 것이다.여기서 우리의 웹브라우저는 어떻게 인터넷상의 수많은 서버들중 네이버 웹툰 서버에 정확히 우리가 원하는 정보를 요청할 수 있을까?IP 주소우리가 쇼핑몰에서 물건을 주문 했다면 택배를 통해 물건을 받을 수 있다. 어떻게 전국에 수많은 집들 중 정확히 나에게 배송이 가능한 것일까?그것은 송장에 배송지 주소가 있기 때문이다.이렇듯 우리가 인터넷상에서 원하는 서버를 정확히 찾아가기 위해서는 주소가 필요하고 이를 IP 주소라 한다.그리고 택배처럼 인터넷 상에 전달되는 데이터를 패킷이라 한다.IP 프로토콜의 한계인터넷 프로토콜이 IP 주소를 활용하여 인터넷 상에서 데이터를 주고 받는 것을 알게되었다. 하지만 이러한 인터넷 프로토콜은몇가지 한계점이 있다. 비연결성 비신뢰성 프로그램 구분비연결성만약 패킷을 받을 대상이 없거나 서버가 꺼져있는 경우는 어떻게 될까? 인터넷 프로토콜은 대상이 없거나 서비스 불능 상태여도 패킷을 전송한다.마치 편지를 보내는 것과 같이 정보가 제대로 갔는지 보장하지 않는다.비신뢰성만약 패킷을 전달하는데 중간에 패킷이 사라지거나 여러개를 전달했는데 순서가 섞여서 오는 경우는 어떻게 될까?예를 들어 Hello라는 문장과 World라는 문장 두개를 같이 전달했을 때 순서가 보장되지 않아 World Hello라고 오는 경우이다.인터넷 프로토콜은 이러한 문제를 해결할 수 없다.프로그램 구분만약 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상인 경우는 어떻게 될까?예를 들어 택배를 배송하기 위해 주소를 보고 찾아왔는데 아파트였다. 그런데 동과 호수 정보가 기입되어 있지 않다.이 경우 배송을 할수가 없다.결론결론적으로 인터넷 프로토콜은 몇가지 한계점으로 인해 TCP 프로토콜과 함께 사용된다. TCP에 대해서는 다음 포스팅에서 다루도록 하겠다.참고 인프런 모든 개발자를 위한 HTTP 웹 기본 지식(김영한) 위키백과 인터넷 프로토콜" }, { "title": "인터넷과 HTTP 프로토콜", "url": "/posts/http-01/", "categories": "HTTP", "tags": "HTTP", "date": "2022-02-09 00:00:00 +0900", "snippet": "인터넷 통신지금부터 인터넷이 동작하는 가장 기본적인 원리를 알아보려 한다. 우선 인터넷이란 무엇일까?인터넷(Internet)은 인터넷 프로토콜(TCP/IP)을 기반으로 하여 전 세계적으로 연결되어있는 컴퓨터 네트워크 통신망을 일컫는 말이다.그렇다면 인터넷에서 컴퓨터는 어떻게 통신할 수 있을까? 우선 인터넷이 동작하기 위해서는 최소 두대의 컴퓨터가 필요하다.그리고 각각을 클라이언트와 서버라고 하겠다.카카오톡 PC버전을 설치하는 상황을 떠올려보자.우선 우리는 크롬이나 익스플로러와 같은 웹브라우저를 실행시키고 카카오톡 설치 사이트에서 파일을 다운로드 받을 것이다.이때 우리는 웹브라우저를 통해서 카카오톡 파일을 요청하게된다. 그렇다면 설치파일은 누구에게서 받는 것일까?이때 우리에게 응답을 해주는 것이 서버이다.여기서 중요한 단어는 요청과 응답이다. 우리는 인터넷을 통해서 그림이나, 문서, 파일등을 요청한다. 그리고 이러한 요청에 대한 응답을 받는다.그리고 이렇게 클라이언트와 서버 간에 요청/응답 프로세스를 가능하게 해주는 것이 HTTP 프로토콜이다.HTTP 란?HTTP(HyperText Transfer Protocol)는 WWW(World Wide Web)상에서 정보를 주고받을 수 있는 프로토콜을 말하고 주로 HTML 문서를 주고받는데 쓰인다.위에서 살펴본 클라이언트와 서버 구조를 다시 생각해보면 클라이언트는 웹 브라우저를 가지고 서버로 URL을 요청한다.정확하게는 HTTP request를 요청한다. 서버는 이 요청을 받아 HTTP response로 응답하게 된다.이것이 HTTP의 기본적인 흐름이다.HTTP의 특징 클라이언트 서버 구조 무상태 프로토콜(StateLess) 비 연결성(Connectionless)클라이언트 서버 구조HTTP는 클라이언트가 서버에 요청을 보내고 응답을 대기한다. 그리고 서버가 요청에 대한 결과를 만들어서 응답한다는 단순한 구조로 되어있다. Request(요청) / Response(응답) 구조 클라이언트는 서버에 요청을 보내고, 응답을 대기 서버가 요청에 대한 결과를 만들어서 응답무상태 프로토콜 (Stateless)무상태 프로토콜은 서버가 클라이언트의 상태를 보존하지 않는다는 것이다.예시Stateful(상태유지)고객: 이 노트북 얼마인가요?점원: 100만원 입니다.고객: 2개 구매하겠습니다.점원: 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요?고객: 신용카드로 구매하겠습니다.점원: 200만원 결제 완료되었습니다.Stateless(무상태)고객: 이 노트북 얼마인가요?점원: 100만원 입니다. (노트북 상태 유지)고객: 노트북 2개 구매하겠습니다.점원: 노트북 2개는 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요? (노트북, 2개 상태 유지)고객: 노트북 2개를 신용카드로 구매하겠습니다.점원: 200만원 결제 완료되었습니다. (노트북, 2개, 신용카드 상태 유지)위의 예시를 조금 더 쉽게 이해하기 위해서는 점원이 바뀌는 경우를 생각해보면 된다.점원 A에게 음료를 주문하고 점원 B를 통해 결제를 하려한다면 점원 B에게 어떤 음료를 주문 했는지를 다시 알려주어야 한다.이처럼 무상태 프로토콜은 클라이언트가 추가 데이터를 전송해야 하는 단점이 존재한다.반면에 추가 데이터만 전송한다면 점원이 변해도 주문을 완료할 수 있듯 서버의 확정성을 높이 수 있다.(스케일 아웃)비 연결성(Connectionless)비 연결성은 서버와 클라이언트가 통신이 끝난 뒤 연결을 해제하여 연결 상태를 유지하지 않는다는 것이다.이는 통신할때 마다 다시 연결하여 데이터를 전달 받은 후 연결을 해제하는 것을 말한다.비효율적인 방식으로 보이지만 웹 서비스의 경우를 생각해보면 효율적인 방법이라는 것을 알수 있다.보통 웹 서비스는 1시간 동안 수천명에서 수만명이 서비스를 사용한다. 이때 이들의 연결을 유지한다고 생각한다면 서버는 엄청난 리소스를 부담하고 있어야한다.그리고 클라이언트는 계속해서 서버에 데이터를 요청하지 않는다. 예를 들어 우리가 구글에서 원하는 정보를 검색한 후 검색결과 페이지에 머무르는 시간이 존재한다는 것이다.이 경우에는 연결을 유지하는 것이 비효율적이다. 반대로 비 연결성은 서버 자원을 매우 효율적으로 사용할 수 있다.참고 인프런 모든 개발자를 위한 HTTP 웹 기본 지식(김영한) 생활코딩 HTML &amp;amp; Internet 위키백과 HTTP" }, { "title": "빈 스코프", "url": "/posts/spring-12/", "categories": "Spring", "tags": "Srping, 빈 생명주기", "date": "2022-02-07 00:00:00 +0900", "snippet": "빈 스코프빈 스코프는 말 그대로 빈이 존재할 수 있는 범위를 뜻한다. 우리는 스프링 빈이 스프링 컨테이너의 시작과 함께 생성되어 컨테이너가종료될 때 까지 유지된다고 학습했다. 이것은 스프링 빈이 기본적으로 싱클톤 스코프로 생성되기 때문이다.하지만 때에 따라서는 HTTP 요청마다 다른 빈을 생성해서 써야하거나 매번 사용될 때 마다 빈을 생성하는 경우도 있다.이를 위해 스프링은 다음과 같이 다양한 스코프를 지원한다. 싱글톤 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프 프로토타입 스프링 컨테이너가 빈의 생성과 의존관계 주입까지만 관여한다. 매우 짧은 범위의 스코프 request 웹 요청이 들어오고 나갈때 까지 유지되는 스코프 session 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프 application 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프 프로토타입싱글톤 스코프의 빈을 조회하면 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈을 반환한다.반면에 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환한다.싱글톤 빈과는 달리 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다.그래서 @PreDestroy 같은 종료 메서드가 호출되지 않는다.프로토타입 빈의 생성은 @Scope(&quot;prototype&quot;) 어노테이션을 활용하면 된다.@Scope(&quot;prototype&quot;)@Componentpublic class PrototypeBean {}@Configurationpublic class AppConfig { @Scope(&quot;prototype&quot;) @Bean PrototypeBean prototypeBean() { return new PrototypeBean(); }}프로토타입 빈의 특징 스프링 컨테이너에 빈을 요청할 때마다 새로 생성된다. 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여한다. 종료 메서드가 호출되지 않는다.웹 스코프웹 스코프는 reqeust, session, application 스코프등이 해당된다. 웹 스코프는 웹 환경에서만 동작하고 프로토타입과다르게 스프링 컨테이너가 해당 스코프의 종료시점까지 관리한다.웹 스코프 종류 request HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리된다. session HTTP Session과 동일한 생명주기를 가지는 스코프 application 서블릿 컨텍스트(ServletContext)와 동일한 생명주기를 가지는 스코프 websocket 웹 소켓과 동일한 생명주기를 가지는 스코프 참고 인프런 스프링 핵심원리 - 기본편(김영한) 토비의 스프링" }, { "title": "빈 생명주기(Bean Lifecycle)", "url": "/posts/spring-11/", "categories": "Spring", "tags": "Srping, 빈 생명주기", "date": "2022-02-07 00:00:00 +0900", "snippet": "빈 생명주기스프링 컨테이너는 빈 객체를 생성하고, 프로퍼티를 할당하고, 초기화를 수행하고, 사용이 끝나면 소멸시키는 일련의 과정을 관리한다.스프링 빈은 객체를 생성하고, 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료된다.스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공한다.또한 스프링은 컨테이너가 종료되기 직전에 소멸 콜백을 준다.스프링 컨테이너 생성 -&amp;gt; 스프링 빈 생성 -&amp;gt; 의존관계 주입 -&amp;gt; 초기화 콜백 -&amp;gt; 사용 -&amp;gt; 소멸전 콜백 -&amp;gt; 스프링 종료 초기화 콜백: 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출 소멸전 콜백: 빈이 소멸되기 직전에 호출스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 지원한다. 인터페이스(InitializingBean, DisposableBean) 설정 정보에 초기화 메서드, 종료 메서드 지정 @PostConstruct, @PreDestroy 어노테이션 지원인터페이스(InitializingBean, DisposableBean)InitializingBean와 DisposableBean 인터페이스를 구현해서 빈을 작성하는 방법이다. InitializingBean의 afterPropertiesSet()메서드는 이름 그대로 프로퍼티 설정까지 마친 뒤에 호출된다. 그리고 DisposableBean의 destroy() 메서드는 빈이 소멸 되기 직전에 호출된다.public class BeanLifecycle implements InitializingBean, DisposableBean { @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;afterPropertiesSet&quot;); System.out.println(&quot;프로퍼티 설정까지 마친 뒤에 호출&quot;); } @Override public void destroy() throws Exception { System.out.println(&quot;destroy&quot;); System.out.println(&quot;빈이 소멸 되기 직전에 호출&quot;); }}이 방법은 별로 권장되지 않는다. 애플리케이션 빈 코드에 스프링 인터페이스를 노출하기 때문이다. 또 다른 방법이 더 간결하기때문이기도 하다. 반면에 인터페이스를 보고 코드의 동작방식을 이해하기 쉽다는 장점도 있다.설정 정보에 초기화 메서드, 종료 메서드 지정public class BeanLifecycle { public void init() throws Exception { System.out.println(&quot;init&quot;); System.out.println(&quot;프로퍼티 설정까지 마친 뒤에 호출&quot;); } public void close() throws Exception { System.out.println(&quot;close&quot;); System.out.println(&quot;빈이 소멸 되기 직전에 호출&quot;); }}@Configurationpublic class LifecycleConfig { @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;close&quot;) public BeanLifecycle beanLifecycle() { return new BeanLifecycle(); }}초기화 콜백 인터페이스를 사용히는 방법과 달리 빈 클래스에 스프링 API가 노출되지 않기 때문에 깔끔하다는 장점이 있는 반면코드만 보고는 초기화 메소드가 호출될지 알 수 없기 때문에 코드를 이해하는 데 불편할 수 있다.@PostConstruct, @PreDestroy 어노테이션이 방법은 어노테이션을 활용한 방법으로 초기화를 담당할 메서드에 @PostConstruct 종료를 담당할 메서드에 @PreDestroy를 붙여주면 된다.public class BeanLifecycle { @PostConstruct public void init() throws Exception { System.out.println(&quot;init&quot;); System.out.println(&quot;프로퍼티 설정까지 마친 뒤에 호출&quot;); } @PreDestroy public void close() throws Exception { System.out.println(&quot;close&quot;); System.out.println(&quot;빈이 소멸 되기 직전에 호출&quot;); }}이 방법은 최신 스프링에서 가장 권장하는 방법이다. 그리고 어노테이션 하나만 붙이면 되므로 매우 편리하다.단점은 외부 라이브러리에 적용하지 못한다는 점이다. 만약 외부 라이브러리의 코드를 수정할 수 없지만 초기화, 종료 작업이 필요하다면@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;close&quot;) 기능을 활용하면 된다.참고 인프런 스프링 핵심원리 - 기본편(김영한) 토비의 스프링" }, { "title": "다양한 의존관계 주입", "url": "/posts/spring-10/", "categories": "Spring", "tags": "Srping, 의존관계 주입", "date": "2022-02-03 00:00:00 +0900", "snippet": "다양한 의존관계 주입이전 포스팅에서 스프링의 컴포넌트 스캔과 의존관계 주입에 대해 알아 보았다.스프링은 @Autowired 어노테이션을 통해 편리하게 의존관계를 주입 받을 수 있도록 기능을 제공한다.이번 포스팅에서는 스프링이 지원하는 다양한 DI 방식을 알아보려 한다. 크게 4가지 방식이 있다. 생성자 주입 수정자 주입(setter 주입) 필드 주입 일반 메서드 주입생성자 주입먼저 생성자 주입에 대해 알아보자. 이 방식은 이름 그대로 생성자를 통해서 의존관계를 주입 받는 방법이다.@Componentpublic class MemberService { private final MemberRepository memberRepository; @Autowired public MemberService(MemberRepository memberRepository) { this.memberRepository = memberRepository; }}(생성자가 딱 1개만 있으면 @Autowired를 생략해도 된다.)생성자 주입의 특징은 딱 1번만 호출되는 것이 보장 된다는 것이다. 그리고 final 키워드를 통해 불변 객체로 사용할 수 있다. 생성자 호출 시점에 딱 1번만 호출되는 것이 보장 불변, 필수 의존관계에 사용수정자 주입(setter 주입)수정자 주입은 setter 메서드를 통해 의존관계를 주입받는 방법이다.@Componentpublic class MemberService { private MemberRepository memberRepository; @Autowired public void setMemberService(MemberRepository memberRepository) { this.memberRepository = memberRepository; }}수정자 주입의 특징은 의존관계를 선택적으로 주입 받거나 로직 중간에 변경이 필요한 경우 사용할 수 있다. 선택, 변경 가능성이 있는 의존관계에 사용필드 주입필드 주입은 생성자나 수정자 메서드 없이 필드에 바로 주입받는 방법이다.@Componentpublic class MemberService { @Autowired private MemberRepository memberRepository;}코드가 간결하다는 특징이 있지만 이 경우 외부에서 의존관계를 변경할 수 없다는 단점이 존재한다.그로인해 테스트가 어려워지는 치명적인 단점이 존재한다.또한 DI 프레임워크가 없으면 의존관계를 주입받을 수 없는 단점도 존재한다. 이로 인해 필드 주입은 권장하지 않는다.일반 메서드 주입이 방식은 일반 메서드를 통해 주입을 받는 방식이다.@Componentpublic class MemberService { private MemberRepository memberRepository; @Autowired public void init(MemberRepository memberRepository) { this.memberRepository = memberRepository; }}한번에 여러 필드를 주입 받을 수 있다는 장점이 있지만 일반적으로 잘 사용하지 않는다.Lombok을 활용한 생성자 주입과거에는 수정자 주입과 필드 주입을 많이 사용했지만, 최근 스프링을 포함한 대부분의 DI 프레임워크는 생성자 주입을 권장하고 있다.이는 아래와 같은 특징들 때문이다.우선 생성자 주입을 설명하며 불변이라는 단어를 사용하였다.실제 애플리케이션을 개발하면 의존관계는 종료시점까지 변경되는 일이 거의 없다. 오히려 대부분은 종료시점까지 변경되면 안되는 경우가 많다.그리고 수정자 메서드의 경우는 누군가 실수로 변경할 수 있기 때문에 이러한 setter 메서드를 열어두는 것은 좋지 않다.결론적으로 의존관계를 불변하게 설계해야 하는데 생성자 주입은 딱 1번만 호출되는 것이 보장됨은 물론이고 불변하게 설계가 가능하다!@Componentpublic class MemberService { private final MemberRepository memberRepository; @Autowired public MemberService(MemberRepository memberRepository) { this.memberRepository = memberRepository; }}최근 트렌드는 롬복을 사용하여 위의 코드를 아래와 같이 작성한다.@Component@RequiredArgsConstructorpublic class MemberService { private final MemberRepository memberRepository;}final 키워드가 있기 때문에 위 코드는 초기화를 위해 생성자를 필요로 한다. @RequiredArgsConstructor 어노테이션은이렇게 final 키워드가 붙은 필드들을 초기화하는 생성자를 자동 생성해준다.정리최근에는 생성자를 딱 1개 두고, @Autowired를 생략하는 방법을 주로 사용한다.여기에 @RequiredArgsConstructor를 통해 필요한 생성자를 자동 생성하여 코드를 간결하게 사용한다.참고 인프런 스프링 핵심원리 - 기본편(김영한) 토비의 스프링" }, { "title": "컴포넌트 스캔과 의존관계 주입", "url": "/posts/spring-09/", "categories": "Spring", "tags": "Srping, Component Scan, 의존관계 주입", "date": "2022-01-25 00:00:00 +0900", "snippet": "컴포넌트 스캔(Component Scan)이번 포스팅에서는 스프링의 컴포넌트 스캔에 대해 알아보려한다. 이전에 우리는 오브젝트 팩토리를 직접 만들고 이를 설정정보로 사용하는애플리케이션 컨텍스트도 만들어보았다.그런데 실무에서는 예제와 달리 등록해서 사용해야할 빈이 수십, 수백개가 될 수도 있다.이럴경우 설정정보가 커지고 누락하는 등의 문제가 발생될 수 있다.스프링에서는 설정 정보가 없어도 자동으로 스프링 빈을 등록해주는 기능을 제공하는데 이를 컴포넌트 스캔이라 한다.또한 이렇게 등록된 빈의 의존관계를 자동으로 주입해주는 Autowired라는 기능도 제공한다.@Configuration@ComponentScanpublic class AutoAppConfig {}@Componentpublic class MemberService { private MemberRepository memberRepository; public MemberService(MemberRepository memberRepository) { this.memberRepository = memberRepository; }}@ComponentScan 어노테이션을 사용하면 @Component를 가진 모든 대상을 가져와 자동으로 빈으로 등록해준다.컴포넌트 스캔 범위스캔범위는 @ComponentScan 어노테이션이 있는 파일의 패키지부터 하위 패키지를 탐색한다.일반적으로는 @ComponentScan을 사용하는 클래스를 프로젝트 최상단에 위치 시킨다.(basePackages나 basePackageClasses를 지정할 수도 있다.)@Configuration@ComponentScan(basePackages = &quot;com.xxx.xxx&quot;, basePackageClasses = &quot;com.xxx.xxx.AutoAppConfig.class&quot;)public class AutoAppConfig {}(SpringBoot 사용 시 @SpringBootApplication 어노테이션에 @ComponentScan이 포함되어 있다.)의존관계 주입컴포넌트 스캔을 통해 자동으로 빈을 등록해 보았다. 이제 이전처럼 빈팩토리를 수동으로 만들지 않아도 스프링이 자동으로 빈을 등록하고관리해준다.그런데 기존에 수동으로 빈 팩토리를 만들때는 이름이나 타입정보를 알고 있기 때문에 getBean()을 통해 빈을 가져올 수 있었다.하지만 지금은 AutoAppConfig에 어떠한 정보도 작성되지 않았기 때문에 빈을 가져오기 위한 이름이나 타입정보를 확인할 수 없다.이 경우에 사용하는 것이 @Autowired이다. 이 어노테이션이 붙어 있으면 스프링이 자동으로 빈을 주입해준다.@Componentpublic class MemberService { private MemberRepository memberRepository; @Autowired public MemberService(MemberRepository memberRepository) { this.memberRepository = memberRepository; }}위의 코드처럼 @Autowired를 붙이면 MemberRepository 타입을 확인하고 스프링이 자동으로 빈을 주입해준다.참고 인프런 스프링 핵심원리 - 기본편(김영한) 토비의 스프링" }, { "title": "싱글톤 레지스트리", "url": "/posts/spring-08/", "categories": "Spring", "tags": "Srping, 싱글톤 레지스트리", "date": "2022-01-19 00:00:00 +0900", "snippet": "싱글톤 레지스트리이전 까지 우리는 스프링 애플리케이션 컨텍스트에 대해 알아보았다. 애플리케이션 컨텍스트는 오브젝트 팩토리와 비슷한 방식으로 동작하는IoC 컨테이너이다. 그러면서 동시에 이 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이기도 하다.싱글톤 패턴(Singleton Pattern)싱글톤 레지스트리를 알아보기 전에 싱글톤 패턴에 대해 먼저 알아보자.싱글톤 패턴은 어떤 클래스를 애플리케이션 내에서 제한된 인수턴스 수를 가지도록 하는것이다.보통은 이름처럼 하나만 존재하도록 강제하는 패턴이다.서버 애플리케이션과 싱글톤왜 스프링에서 싱글톤 개념이 나오는 것일까? 이는 스프링이 태생적으로 자바 엔터프라이즈 기술을 사용하는 서버환경을 위해 고안된 기술이기 때문이다.여기서 말하는 서버환경은 서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 여타 시스템으로 부터 요청을 받아 처리할 수 있는 높은성능이 요구되는 환경이다.만약 한번의 요청에 5개의 오브젝트가 만들어 진다고 가정해보면, 초당 500번의 요청을 처리하기 위해서는 2500개의 오브젝트가 생성된다.아무리 자바의 오브젝트 생성과 가비지 컬렉션의 성능이 좋아졌다고 한들 이렇게 부하가 걸리면 서버가 감당하기 힘들어 진다.이런 이유로 서버환경에서는 싱글톤의 사용이 권장된다.안티패턴 싱글톤서버환경에서는 싱글톤의 사용이 권장된다고 하였지만 디자인 패턴 관점에서는 피해야할 패턴인 안티패턴으로 분류된다.우선 간단히 싱글톤 오브젝트를 만들어보겠다.public class Singleton { private static Singleton instance = new Singleton(); public static Singleton getInstance() { return instance; } private Singleton() {}} 싱글톤 오브젝트는 생성된 오브젝트를 저장하기 위해 자신과 같은 타입의 스태틱 필드를 정의한다. 외부에서 오브젝트를 생성하지 못하도록 생성자를 private으로 만든다. 마지막으로 생성된 오브젝트를 반환해줄 getInstance 스태틱 메소드를 만든다.자바에서 싱글톤을 구현하는 방법은 보통 위와 같다. 하지만 일반적으로 싱글톤 패턴 구현 방식에는 다음과 같은 문제가 있다. private 생성자로 인해 상속할 수 없다. 테스트가 힘들다. 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다. 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.스프링 - 싱글톤 레지스트리싱글톤에는 다양한 문제점이 존재한다. 하지만 스프링은 서버환경에서 오브젝트를 싱글톤 방식으로 사용되는 것을 적극 지지한다.그로인해 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 바로 싱글톤 레지스트리다.그리고 싱글톤 레지스트리는 다음과 같은 장점을 가진다. public 생성자를 가질 수 있다. 테스트가 간단하다. 객체지향적인 설계 방식과 원칙, 디자인 패턴등을 적용하는데 아무런 제약이 없다.public class SingletonTest { public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(MemberFactory.class); MemberRepository memberRepository1 = context.getBean(&quot;memberRepository&quot;, MemberRepository.class); MemberRepository memberRepository2 = context.getBean(&quot;memberRepository&quot;, MemberRepository.class); System.out.println(&quot;memberRepository1 = &quot; + memberRepository1); System.out.println(&quot;memberRepository2 = &quot; + memberRepository2); // memberRepository1 = hello.core.member.MemoryMemberRepository@6eeade6c // memberRepository2 = hello.core.member.MemoryMemberRepository@6eeade6c }}위의 코드를 실행해보면 스프링이 객체의 싱글톤을 보장해 주는 것을 알 수 있다.스프링이 빈을 싱글톤으로 만드는 것은 결국 오브젝트의 생성 방법을 제어하는 IoC 컨테이너로서의 역할이다. 위의 코드를 통해 확인하였듯이스프링 IoC를 적용하면 싱글톤 객체로 만들어진다. 그래서 getBean()을 여러 번 호출하여 요청하더라도 매번 동일한 오브젝트를 받게 된다.참고 인프런 스프링 핵심원리 - 기본편(김영한) 토비의 스프링" }, { "title": "스프링 빈 조회", "url": "/posts/spring-07/", "categories": "Spring", "tags": "Srping, Bean, ApplicationContext", "date": "2022-01-17 00:00:00 +0900", "snippet": "스프링 빈 조회이전 포스팅에서 애플리케이션 컨텍스트에 대해 알아보았고 MemberFacotry를 설정정보로 사용하는 애플리케이션 컨텍스트를 만들어 보았다.이제 애플리케이션 컨텍스트에서 빈을 가져오는 방법을 알아보자. 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.빈 이름으로 조회MemberFactory를 설정정보로 사용하는 어플리케이션 컨텍스트를 만들고 getBean() 메서드를 이용해 빈을 가져온다. 파라미터는 빈 메서드 명(이름)과 타입을 입력하면 된다.public class ApplicationContextTest { public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(MemberFactory.class); MemberRepository memberRepository = context.getBean(&quot;memberRepository&quot;, MemberRepository.class); }}이름으로 검색할 때 해당하는 이름의 빈이 없는 경우가 있다. 이 때는 NoSuchBeanDefinitionException 예외가 발생한다.빈 타입으로 조회파라미터에서 이름을 생략할 수도 있다. 이 경우 해당 타입의 빈을 조회한다.public class ApplicationContextTest { public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(MemberFactory.class); MemberRepository memberRepository = context.getBean(MemberRepository.class); }}이때 만약 동일한 타입이 둘 이상일 경우는 어떻게 될까?동일한 타입이 둘 이상인 빈 조회public class ApplicationContextTest { public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(MemberFactory.class); MemberRepository memberRepository = context.getBean(MemberRepository.class); }}@Configurationpublic class MemberFactory { @Bean public MemberRepository memberRepository1() { return new JdbcMemberRepository(); } @Bean public MemberRepository memberRepository2() { return new JdbcMemberRepository(); }}결론부터 말하면 이 경우 NoUniqueBeanDefinitionException 예외가 발생 된다. 여러 해결 방법이 있고자세한 내용은 이후 포스팅에서 설명할 예정이다. 가장 쉬운 방법은 위 예제 처럼 빈 이름을 지정하면 된다.구체 타입으로 조회public class ApplicationContextTest { public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(MemberFactory.class); MemberRepository memberRepository = context.getBean(JdbcMemberRepository.class); }}인터페이스를 상속한 구체 타입이 있을 경우 해당 구체 타입으로 조회가 가능하다. 하지만 우리는 역할과 구현을 나누고 역할에 의존해야 한다고 배웠다.위의 코드는 역할이 아닌 구현에 의존하고 있다. 그렇기 때문에 가급적 다른 방식을 활용할 것을 추천한다.상속관계에 있는 빈 조회만약 빈이 상속관계에 있는 경우에 부모 타입을 조회하면 어떻게 될까? 이때는 자식 타입도 함께 조회 된다.(Object 타입으로 조회 시 모든 스프링 빈이 조회 된다.)public class ApplicationContextTest { public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(MemberFactory.class); MemberRepository memberRepository = context.getBean(MemberRepository.class); }}@Configurationpublic class MemberFactory { @Bean public MemberRepository jdbcMemberRepository() { return new JdbcMemberRepository(); } @Bean public MemberRepository memoryMemberRepository() { return new MemoryMemberRepository(); }}위의 경우는 동일한 타입이 둘 이상인 빈 조회할 때와 같은 상황이다. MemberRepository에 대한 구현체 모두가 조회되기 때문에NoUniqueBeanDefinitionException 예외가 발생 된다.부모 타입으로 모두 조회하기동일한 타입이 둘 이상일 경우 빈을 하나만 조회 하는 것이 아닌 모든 빈을 조회하는 방법도 있다.public class ApplicationContextTest { public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(MemberFactory.class); Map&amp;lt;String, MemberRepository&amp;gt; beanOfType = context.getBeansOfType(MemberRepository.class); for (String key : beansOfType.keySet()) { System.out.println(&quot;value = &quot; + beansOfType.get(key)); } }}@Configurationpublic class MemberFactory { @Bean public MemberRepository jdbcMemberRepository() { return new JdbcMemberRepository(); } @Bean public MemberRepository memoryMemberRepository() { return new MemoryMemberRepository(); }}참고 인프런 스프링 핵심원리 - 기본편(김영한) 토비의 스프링" }, { "title": "애플리케이션 컨텍스트", "url": "/posts/spring-06/", "categories": "Spring", "tags": "Srping, Bean Factory, ApplicationContext", "date": "2022-01-14 00:00:00 +0900", "snippet": "애플리케이션 컨텍스트스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈(bean)이라하고빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리(bean factory)라고 부른다.그리고 스프링에서는 빈 팩토리를 확장한 애플리케이션 컨텍스트(application context)를 주로 사용한다.애플리케이션 컨텍스트는 IoC 방식을 따라 만들어진 일종의 빈 팩토리라고 생각하면 된다.public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver { ....} MessageSource: 국제화 기능 EnvironmentCapable: 로컬, 개발, 운영등을 구분해서 처리 ApplicationEventPublisher: 이벤트를 발행하고 구독하는 모델을 편리하게 지원 ResourceLoader: 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회 BeanFactory: 스프링 컨테이너의 최상위 인터페이스로 스프링 빈을 관리하고 조회하는 역할애플리케이션 컨텍스트는 별도의 정보를 참고해서 빈의 생성, 관계설정 등의 제어 작업을 총괄한다.기존 MemberFactory 코드에는 설정정보, 예를 들어 어떤 클래스의 오브젝트를 생성하고 어디에서 사용하도록 연결해줄 것인가 등에 관한 정보가평범한 자바 코드로 만들어져 있다. 애플리케이션 컨텍스트는 이런 정보를 담고 있진 않다.대신 별도로 설정정보를 담고 있는 무엇인가를 가져와 이를 활용하는 범용적인 IoC엔진 같은 것이라고 볼 수 있다.애플리케이션 컨텍스트의 동장방식기존에 오브젝트 팩토리를 이용했던 방식과 스프링의 애플리케이션 컨텍스트를 사용한 방식을 비교해보자.오브젝트 팩토리에 대응되는 것이 스프링의 애플리케이션 컨텍스트다. 스프링에서는 이 애플리케이션 컨텍스트를 IoC 컨테이너라 하기도 하고,간단히 스프링 컨테이너라고 부르기도 한다. 또는 빈 팩토리라고 부를 수도 있다.우리가 이전 포스팅에서 만든 MemberFactory는 MemberRepository 오브젝트를 생성하고 이를 활용하는 오브젝트와 관계를 맺어주는제한적인 역할을 한다. 반면에 애플리케이션 컨텍스트는 애플리케이션에서 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계설정을 담당한다.또한 애플리케이션 컨텍스트는 MemberFactory와 달리 직접 오브젝트를 생성하고 관계를 맺어주는 코드가 없고, 그런 생성정보와 연관관계 정보를별도의 설정정보를 통해 얻는다.@Configuration이 붙은 MemberFactory는 이 애플리케이션 컨텍스트가 활용하는 IoC 설정정보다.내부적으로는 애플리케이션 컨텍스트가 MemberFactory의 memberRepository() 메소드를 호출해서 오브젝트를 가져온 것을클라이언트가 getBean()으로 요청할 때 전달해준다.애플리케이션 컨텍스트를 사용할 경우 장점 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다참고 인프런 스프링 핵심원리 - 기본편(김영한) 토비의 스프링" }, { "title": "스프링의 IoC", "url": "/posts/spring-05/", "categories": "Spring", "tags": "Srping, IoC, Object Factory, ApplicationContext", "date": "2022-01-12 00:00:00 +0900", "snippet": "스프링의 IoC스프링은 애플리케이션 개발의 다양한 영역과 기술에 관여한다. 그리고 매우 많은 기능을 제공한다.하지만 스프링의 핵심을 담당하는 건, 바로 빈 팩토리 또는 애플리케이션 컨텍스트라고 불리는 것이다.이 두 가지는 우리가 만든 MemberFactory가 하는 일을 좀 더 일반화한 것이라고 설명할 수 있다.오브젝트 팩토리를 이용한 스프링 IoC팩토리먼저 우리가 만든 MemberFactory를 살펴보자. 이 클래스의 역할은 무엇일까?public class MemberFactory { public MemberRepository memberRepository() { return new JdbcMemberReposititory(); }}이 클래스는 단순히 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 역할만을 한다. 이런 일을 하는 오브젝트를 흔히 팩토리(Factory)라고 부른다.이러한 팩토리는 단지 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용한다.(MemberFactory를 통해 우리는 OCP와 DIP를 지킬 수 있었다)스프링에서 MemberFactory 사용하기이제 MemberFactory를 스프링에서 사용이 가능하도록 변경해 보려한다.@Configurationpublic class MemberFactory { @Bean public MemberRepository memberRepository() { return new JdbcMemberReposititory(); }}먼저 스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할 수 있도록 @Configuration이라는 어노테이션을 추가하였다.그리고 오브젝트를 만들어주는 메소드에는 @Bean이라는 어노테이션을 붙여주었다.이 두가지 어노테이션만으로 스프링 프레임워크의 빈 팩토리가 IoC 방식의 기능을 제공할 수 있다.애플리케이션 컨텍스트스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈(bean)이라고 부른다.그리고 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리(bean factory)라고 부른다. 빈(bean) : MemberRepository 빈 팩토리(bean factory) : MemberFactory이후 자세히 설명하겠지만 보통 빈 팩토리보다는 이를 좀 더 확장한 애플리케이션 컨텍스트(application context)를 주로 사용한다.애플리케이션 컨텍스트는 IoC 방식을 따라 만들어진 일종의 빈 팩토리라고 생각하면 된다.애플리케이션 컨텍스트는 별도의 정보를 참고해서 빈(bean)의 생성, 관계설정 등의 제어 작업을 총괄한다.(위의 코드에서 사용한@Configuration과 @Bean이 별도의 설정정보에 해당한다. 이를 통해 어떤 클래스의 오브젝트를 생성하고 어디에서 사용하도록 연결해줄 것인가를 판단한다.)아래의 코드는 MemberFactory를 설정정보로 사용하는 애플리케이션 컨텍스트를 만든 것이다. 그리고 이를 통해 스프링이 관리하는 빈(bean)인 MemberRepository를 가져 온다.public class ApplicationContextTest { public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(MemberFactory.class); MemberRepository memberRepository = context.getBean(&quot;memberRepository&quot;, MemberRepository.class); MemberService memberService = new MemberService(memberRepository); }}정리스프링을 적용한 빈 팩토리를 살펴보았다. 그런데 이전 우리가 순수한 자바 코드로 만든 MemberFactory를 직접 사용한 것과 기능적으로 다를 바 없다.오히려 MemberFactory를 만들어서 바로 사용한 것보다 좀 더 번거로운 작업과 코드가 필요하다.이로인해 스프링을 사용하는 것이 별로 장점이 없지 않을까 하는 의문이 들 수도 있다.하지만 스프링은 우리가 만들었던 MemberFactory가 제공해주지 못하는 많은 이점을 제공해준다. 이러한 특성은 이후 포스팅에서 자세히 다룰 예정이다.참고 인프런 스프링 핵심원리 - 기본편(김영한) 토비의 스프링" }, { "title": "IoC와 DI", "url": "/posts/spring-04/", "categories": "Spring", "tags": "Srping, IoC/DI", "date": "2022-01-12 00:00:00 +0900", "snippet": "IoC와 DI이전 포스팅에서 좋은 객체지향 설계를 위한 SOLID 원칙을 설명하였다. 그리고 다형성만으로는 OCP와 DIP를 지킬 수 없다는 사실도 확인 하였다. 그렇다면 이 문제를 어떻게 해결할 수 있을까?영화를 제작한다고 가정해보자. 먼저 배우를 섭외하고 결정해야 하는데 누가 가장 적임자겠는가? 일반적으로 이는 감독의 역할이다.이제 우리의 프로그램도 연관관계를 맺어주고 결정하는 감독이 필요하다.IoC (Inversion of Control)우리의 프로그램도 이제 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요해 졌다.코드를 통해 살펴보자.public class MemberService { private MemberRepository memberRepository = new JdbcMemberReposititory();}위의 코드는 OCP와 DIP를 위배한 코드이다. 영화 제작의 상황이라면 배우가 상대 배역까지 결정하는 경우와 같다.MemberFactory 등장public class MemberFactory { public MemberRepository memberRepository() { return new JdbcMemberReposititory(); }}public class MemberService { private MemberRepository memberRepository; public MemberService(MemberRepository memberRepository) { this.memberRepository = memberRepository; }}public class MemberFactoryTest { public static void main(String[] args) { MemberFactory memberFactory = new MemberFactory(); MemberService memberService = new MemberService(memberFactory.memberRepository()); }}MemberFactory를 통해 MemberService는 더 이상 구현체에 의존하지 않게 되었다. 그리고 연관관계를 결정하는 것은 MemberFactory의 역할로 바뀌었다.이제 MemberRepository를 변경하더라도 클라이언트인 MemberService는 변경하지 않아도 된다. 다시말해 OCP를 지킬 수 있는 것이다.이제 MemberService의 입장에서 살펴보자. 기존에는 어떤 Repository를 사용할 지 직접 결정 했었다. 그런데 이제는 MemberFactory가 결정하게 되었다.스스로 어떤 객체를 사용할 지 결정 했었는데 이제 그 권한을 MemberFactory가 가져갔다. 다시 말해 제어권을 가져가 버렸다.(제어권이 역전 되었다)이를 제어의 역전 (IoC)이라 한다. 코드에서 보았듯 연관관계를 결정하는 제어권을 다른 객체(또는 스프링 컨테이너 같은)에게 위임함으로써 Repository를 변경하는 것에 있어 자유로울 수 있었다.그리고 이제 MemberService는 구체화에 의존하지 않고 추상화에 의존(DIP)하게 되었다.DI (Dependency Injection)위의 코드를 보면 MemberService는 더 이상 구현체에 의존하지 않고(DIP) MemberRepository의 변경(확장)이 발생해도 영향을 받지 않는다.(OCP)이는 MemberService가 MemberRepository의 의존관계를 외부에서 주입 받기 때문에 가능해졌다. 이렇게 외부에서 의존관계를 주입받는 것을 의존관계 주입(DI)이라 한다.참고 인프런 스프링 핵심원리 - 기본편(김영한) 토비의 스프링" }, { "title": "좋은 객체 지향 설계의 5가지 원칙(SOLID)", "url": "/posts/spring-03/", "categories": "Spring", "tags": "Srping, 객체지향 설계, SOLID", "date": "2022-01-07 00:00:00 +0900", "snippet": "좋은 객체 지향 설계의 5가지 원칙(SOLID)이전 포스팅에 이어서 좋은 객체 지향에 대해 조금 더 자세히 알아보려 한다. 좋은 소프트웨어를 만들기 위해서는 깔끔한 코드도 중요하겠지만 아키텍처 또한 중요하다. 좋은 아키텍처를 정의하기 위해서는 원칙이 필요한데, 지금부터 설명할 SOLID이다.SOLID 원칙SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있다.(중간수준: 모듈 수준에서 작업할 때 적용할 수 있는 수준) 변경에 유연하다. 이해하기 쉽다. 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.5가지 원칙 SRP: 단일 책임 원칙(Single Responsibility Principle) OCP: 개방-폐쇄 원칙(Open-Closed Principle) LSP: 리스코프 치환 원칙(Liskov Substitution Principle) ISP: 인터페이스 분리 원칙(Interface Segregation Principle) DIP: 의존관계 역전 원칙(Dependency Inversion Principle)SRP: 단일 책임 원칙이름만 듣는다면 모든 모듈이 단 하나의 일만 해야 한다고 오해할 수 있지만 SRP는 “단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.”는 의미이다.예를 들어보자 우리의 서비스는 회원관리 기능을 제공한다. 그리고 이를 위해 MemberService를 만들었다. 서비스 운영 중 보안이슈로 인해 우리는 DB 암호를 변경하기로 하였다. 그런데 DB 암호를 변경하기 위해서는 MemberService에 포함된 DB Connection 코드의 일부를 수정해야 하는 일이 벌어졌다.위의 예시는 SRP를 위반한 사례이다. MemberService는 변경의 이유가 두 가지나 되기 때문이다. 회원관리 업무 로직이 변경될 경우 DB Connection 정보가 변경될 경우SRP 원칙을 지킨다는 것은 MemberService의 역할은 회원관리 업무가 유일하고 변경의 이유 또한 회원관리 업무 로직 변경 단 한가지 뿐이어야한다.중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이라 볼 수 있다.OCP: 개방-폐쇄 원칙개방폐쇄 원칙은 “소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.”는 의미이다.다시 말해 기능을 확장할 수 있어야 하고, 이때 기존 코드를 변경해서는 안된다는 말이다. 이전 게시물의 자동차 예제로 잠깐 돌아가보려 한다.우리는 이전에 운전자의 역할과 자동차의 역할에 대해 알아보았다. 이번에는 자동차에 집중해보자.자동차는 역할을 가지고 있고 그에 대한 구현체로 K3, 아반떼, 테슬라 모델3를 가지고 있다. 여기에 새로운 차종인 모닝이 추가된다고 할지라도 운전자에게 영향을 주지 않는다. 그 이유는 역할과 책임을 명확히 분리했기 때문이다.이처럼 기능이 확장(새로운 차종) 되더라도 클라이언트(운전자)는 변경되지 않는다. 다시 말해 다형성을 활용하면 된다.다형성만으로는 해결되지 않는다?OCP 원칙을 적용하기 위해서 다형성을 활용하면 된다고 하였다. 그런데 다형성만으로는 해결되지 않는다는건 무슨 말일까? 코드로 예시를 들어보겠다.public interface MemberRepository { ....}// Memory Repositorypublic class MemoryMemberRepository implements MemberRepository { ....}// Jdbc Repositorypublic class JdbcMemberReposititory implements MemberRepository { ....}우리는 MemberRepository 인터페이스(역할)를 만들었다. 만약 기존 메모리 저장 방식에서 Jdbc 방식으로 기능을 확장하려 한다면 위 코드처럼 JdbcMemberRepository를 추가로 만들어주면 된다.그럼 MemberRepository를 사용하는(클라이언트) MemberService를 보자.public class MemberService { // private MemberRepository memberRepository = new MemoryMemberRepository(); private MemberRepository memberRepository = new JdbcMemberReposititory();}우리는 분명 다형성을 활용하여 역할과 구현을 명확히 분리 하였다. 그렇다면 OCP 원칙이 적용되어 클라이언트인 MemberService는 수정이 없어야 한다. 하지만 구현체를 변경하기 위해서는 MemberService를 변경해야 하는 일이 발생된다. 이는 OCP 원칙을 위반한 것이다.이 문제를 어떻게 해결할 수 있을까? 지금은 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다 정도로 이해하자.LSP: 리스코프 치환 원칙리스코프 치환 원칙은 “상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면 이들 구성요소는 반드시 서로 치환 가능해야한다.”는 의미이다. 한마디로 부모클래스에 자식 클래스를 대입시켜도 문제 없이 작동해야 한다는 말이다.자동차 예시를 다시들면 새로운 차종인 모닝을 만들었다. 그런데 운전자가 브레이크를 밟는 순간 차가 앞으로 나아간다 그리고 핸들을 왼쪽으로 돌렸는데 차가 오른쪽으로 움직인다. 이는 LSP를 위반한 경우이다.분명 자동차는 동작한다.(컴파일러 통과) 하지만 동작의 문제를 넘어 이 경우 아무도 모닝을 구매하지 않을 것이고 기능을 신뢰할 수 없을 것이다. 차는 브레이크를 밟는 순간 멈춰야 하고 핸들을 돌리는 방향으로 움직이여만 한다.ISP: 인터페이스 분리 원칙인터페이스 분리 원칙은 “특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다”는 의미다.예를 들면 자동차 인터페이스 하나 보다는 운전 인터페이스, 정비 인터페이스로 분리하는게 더 좋다는 의미이다.자동차 인터페이스 -&amp;gt; 운전 인터페이스와 정비 인터페이스로 분리이렇게 분리할 경우 정비 인터페이스 자체가 변해도(정비공정이 달라지는 경우 혹은 다른 변경) 운전자에게 영향을 주지 않는다. 한마디로 인터페이스가 명확해지고, 대체 가능성이 높아진다.DIP: 의존관계 역전 원칙의존관계 역전 원칙은 “구체화에 의존하지 말고 추상화에 의존하라”는 의미이다. 쉽게 이야기하면 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻이다.앞서 언급한 OCP 적용 문제점에 대해 다시 이야기해보자.MemberService는 인터페이스에 의존하지만, 동시에 구현 클래스도 의존하고 있다.public class MemberService { // [인터페이스 의존] [구현클래스 의존] private MemberRepository memberRepository = new JdbcMemberReposititory();}위 코드는 OCP 뿐만 아니라 DIP도 위반하고 있다. 결론적으로 다형성만으로는 OCP, DIP를 지킬 수 없다.객체 지향 설계와 스프링다시 스프링으로 돌아와 생각 해보자. 왜 스프링에서 객체 지향에 대한 이야기가 나오는가?이유는 스프링이 아래의 기술들을 통해 OCP와 DIP를 가능하게 지원하기 때문이다. DI(Dependency Injection): 의존관계(의존성) 주입 DI 컨테이너 제공스프링을 사용하면 클라이언트 코드의 변경 없이 기능을 확장할 수 있다. (부품을 교체하듯이 개발)OCP와 DIP 원칙을 지키기 위해서는 스프링을 사용해야 된다 처럼 보일 수 있지만 사실 순수한 자바코드로도 구현은 가능하다. 다만 이 경우 실제 비즈니스 로직의 구현보다 OCP와 DIP원칙을 지키기 위해 구현할 코드의 양이 더 많아질 수 있다.정리 모든 설계에 역할과 구현을 분리하자. 애플리케이션 설계는 공연을 설계 하듯 배역만 만들어두고, 배우는 언제든 유연하게 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계이다. 이상적으로는 모든 설계에 인터페이스를 부여하자 (실무에서의 고민) 하지만 인터페이스를 도입하면 추상화라는 비용이 발생한다. 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩토링하여 인터페이스를 도입하는 것도 좋은 방법이다. 참고 인프런 스프링 핵심원리 - 기본편(김영한) 토비의 스프링 클린 아키텍처 클린 코드" }, { "title": "좋은 객체 지향 프로그래밍이란?", "url": "/posts/spring-02/", "categories": "Spring", "tags": "Srping, 객체지향, 다형성", "date": "2022-01-06 00:00:00 +0900", "snippet": "좋은 객체 지향 프로그래밍 이란?이전 포스팅에서 스프링의 탄생과 배경을 알아보았다. 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있도록 도와주는 프레임워크라 하였는데 좋은 객체 지향 프로그래밍이란 무엇일까? 객체지향 프로그래밍의 사전적 의미부터 알아보자.객체지향 프로그래밍 객체지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 “객체“들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다. 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다. 객체 지향 프로그래밍의 핵심 키워드 추상화: 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것 캡슐화: 실제 구현 내용 일부를 외부에 감추어 은닉 하는 것 상속: 객체들 간의 관계를 구축하는 방법 다형성: 하나의 객체가 여러 가지 타입을 가질 수 있는 것 소프트웨어 아키텍트 관점에서의 객체지향 객체지향이란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다. 위의 내용을 해석해보면 좋은 객체 지향 프로그래밍이란 한마디로 유연하고 변경이 용이 하도록 프로그래밍 하는 것을 말한다. 레고 블럭 조립하듯이 키보드, 마우스를 갈아 끼우듯이 컴퓨터 부품을 갈아 끼우듯이 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법다형성레고 블록을 조립하듯 프로그래밍 한다는 것은 무슨말일까? 그리고 이것은 어떻게 가능한 것일까? 우선 다형성에 대해 알아보자.역할과 구현을 분리지금부터 예시를 들어보려 한다. 우선 우리의 실세계를 역할과 구현으로 구분하여 생각해 보려한다.그림을 보면 운전자와 자동차가 있다. 먼저 운전자와 자동차 둘을 분리하여 표현해보자. 운전자 운전자는 자동차를 운전하는 사람이다. 운전자는 자동차를 사용하는 주체이고 운전을 하는 역할을 가지고 있다. 자동차 자동차는 운전자가 있어야만 움직인다. 자동차는 운전자에 의해 사용되어 진다. 자동차의 역할은 운전자의 조작에 맞게 주행하는 것이다. 자동차는 생산하는 회사와 차종이 다양하다. 세상에는 수 많은 종류의 자동차가 존재한다. 그 자동차들은 제조 회사도 다르고 크기나 종류등 많은 부분이 다르다. 하지만 우리는 그것들을 모두 자동차라고 부른다. 그리고 그 수 많은 자동차들을 운전면허만 있다면 운전이 가능하다.생김새도 다르고 크기도 다르고 그 외 수많은 것들이 다른데 왜 우리는 그 다른 것들의 운전법을 새로 배우지 않고도 운전이 가능한 것일까? 왜 새로운 차종이 출시 되었을 때 우리는 새로운 면허를 취득하지 않아도 되는 것일까?자동차의 역할결론부터 말하면 우리는 자동차의 역할을 알고 있기 때문이다.자동차는 차종과 상관없이 조향장치를 통해 방향을 전환하고 브레이크를 밟으면 정지하고 엑셀레이터를 밟으면 속도가 높아지는 것을 알고 있다. 다시 말해서 새로운 차종이 출시된다 할지라도 그것이 자동차의 역할만 수행한다면 운전자는 아무런 영향을 받지 않는다.다형성이란 이렇게 역할과 구현으로 구분함으로써 그 역할을 수행하는 다양한 형태의 구현으로 대체할 수 있는 것이다. 이렇게 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해진다.자바의 다형성자바에서는 다형성을 어떻게 표현할 수 있을까? 자바는 오버라이딩을 통해 다형성을 표현한다. 역할 = 인터페이스 구현 = 인터페이스를 구현한 클래스, 구현 객체 객체 설계 시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체를 만든다.다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있다.public class MemberService { // private MemberRepository memberRepository = new MemoryMemberRepository(); private MemberRepository memberRepository = new JdbcMemberReposititory();}다형성의 본질프로그래밍 관점에서 이야기 한다면 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있고 이는 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다는 말이다.참고 인프런 스프링 핵심원리 - 기본편(김영한) 클린 아키텍처" }, { "title": "스프링 이란? (스프링의 탄생과 역사)", "url": "/posts/spring-01/", "categories": "Spring", "tags": "Srping", "date": "2022-01-06 00:00:00 +0900", "snippet": "스프링 이란?웹(Web)을 공부하다 보면 가장 많이 나오는 키워드 중 하나는 스프링 프레임워크 일것이다. 많은 IT 업체가 채용 시 스프링 개발 경험을 요구하고 국비지원교육 커리큘럼에 포함되기도 한다. 그리고 공공기관 프로젝트에 권장되는 전자정부 프레임워크도 스프링을 기반으로 만들어졌다.왜 스프링 프레임워크인가?프로그램을 만드는 방식은 다양하다. 언어도 다양하고 기술들도 다양하다. 꼭 스프링이 아니라도 웹 애플리케이션을 만들 수 있다. 그렇다면 왜 수많은 IT 업체들이 스프링 프레임워크를 사용할까? 우선 스프링의 탄생 배경부터 알아보자.자바 엔터프라이즈 개발을 편하게웹 애플리케이션을 만들 때 개발자는 고객의 요구사항을 분석하고 요구사항에 맞는 코드를 작성하게 된다. 이를 비즈니스 로직이라고 부르는데 프로젝트에서 가장 중요한 사항 중 하나다. 한마디로 고객이 원하는 방식으로 프로그램이 동작해야 한다.하지만 프로그램은 비즈니스 로직만으로는 동작하지 않는다. 그 외에도 프로그램 동작을 위한 수많은 로직들이 추가되어야 한다. (트렌잭션, 상태관리, 멀티스레딩, 리소스 풀링과 같은)이때 등장한 것이 EJB(Enterprise Java Beans)라는 자바 표준 기술이다. EJB를 사용하면 앞서 말한 로우레벨(트렌잭션, 상태관리, 멀티스레딩 등) 기술에 신경쓰지 않고 핵심인 비즈니스 로직을 빠르고 효과적으로 구현할 수 있었다.자바 진영의 추운 겨울편리한 애플리케이션 개발이란 개발자가 복잡하고 실수하기 쉬운 로우레벨 기술에 많은 신경을 쓰지 않으면서도 애플리케이션의 핵심인 사용자의 요구사항, 즉 비즈니스 로직을 빠르고 효과적으로 구현하는 것을 말한다. EJB의 비전과 목표는 바로 이것이었다.EJB는 약속대로 일정 부분에서는 엔터프라이즈 개발의 고민거리와 부담을 덜어줬다. 문제는 이 과정에서 다른 차원의 더 큰 복잡함을 애플리케이션 개발에 끌고 들어오는 실수를 저질렀다는 점이다. EJB의 문제점 객체지향적이지 않음 복잡한 프로그래밍 모델 특정 환경, 기술에 종속적인 코드 자동화 된 테스트가 매우 어렵거나 불가능 부족한 개발 생산성, 이동성 구현할 비즈니스 로직보다 EJB 컨테이너를 사용하기 위한 상투적인 코드들이 많다는 불편함은 물론이고 테스트가 어렵다는 문제점등이 있었다. 한마디로 매우 무겁고 복잡하다.이로 인해, 마틴 파울러는 EJB에 반발해 오래된 방식의 간단한 자바 오브젝트로 돌아가자는 말을 했고, 이는 POJO(Plain Old Java Object)라는 용어의 기원이 되었다.겨울을 넘어 봄으로2002년 로드존슨은 Expert One-on-One J2EE Design and Development라는 책을 출간한다. 이 책은 J2EE 애플리케이션 설계와 개발의 모든 영역에 대한 개발 전략을 다룬 책으로 개발 전략과 기존 기술에 대한 대안을 설명으로만 그치지 않고, 그 개념을 증명할 수 있도록 만들어진 3만 라인가량의 샘플 애플리케이션 형태로 제공됐다.이 책에서 강조한 중요한 전략 중 하나는 “항상 프레임워크 기반으로 접근하라”는 것이었다. 책의 예제는 프레임워크를 먼저 만들고 나서, 프레임워크를 이용하는 코드를 만드는 방식으로 작성됐다. 이 예제에 포함된 프레임워크가 스프링 프레임워크의 기원이다.오픈소스 프로젝트의 시작책 출간 직후 예제로 제공된 프레임워크에 매료된 개발자 Juergen Hoeller(유겐 휠러), Yann Caroff(얀 카로프)가 로드 존슨에게 오픈소스 프로젝트를 제안하였고 정식으로 스프링 프레임워크라는 이름의 오픈소스 프로젝트가 시작돼서 오늘날에 이른 것이다. 현재까지 스프링의 핵심 코드의 상당수는 유겐 휠러가 개발하고 있다. 스프링 이름은 전통적인 J2EE(EJB)라는 겨울을 넘어 새로운 시작이라는(봄) 뜻으로 지어졌다. 릴리즈 2003년 스프링 프레임워크 1.0 출시 - XML 2006년 스프링 프레임워크 2.0 출시 - XML 편의 기능 지원 2009년 스프링 프레임워크 3.0출시 - 자바 코드로 설정 2013년 스프링 프레임워크 4.0 출시 - 자바8 2014년 스프링 부트 1.0 출시 2017년 스프링 프레임워크 5.0, 스프링 부트 2.0 출시 - 리엑티브 프로그래밍 지원 2022년 1월 현재 스프링 프레임워크 5.3.14, 스프링 부트 2.6.2스프링 생태계 스프링 프레임 워크 핵심기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타 웹 기술: 스프링 MVC, 스프링 WebFlux 데이터 접근 기술: 트랜잭션, JDBC, ORM지원, XML 지원 기술 통합: 캐시, 이메일, 원격접근, 스케줄링 테스트: 스프링 기반 테스트 지원 언어: 코틀린, 그루비 최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용 스프링 부트 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성 Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨 손쉬운 빌드 구성을 위한 starter 종속성 제공 스프링 3rd parth(외부) 라이브러리 자동 구성 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공 관례에 의한 간결한 설정그외 스프링 데이터 스프링 세션 스프링 시큐리티 스프링 배치 스프링 클라우드 스프링 RestDocs 엔터프라이즈 개발의 복잡함2000년대 초반 각종 자바 컨퍼런스에서 자주 논의됐던 주제는 “왜 자바 엔터프라이즈 JavaEE 프로젝트는 실패하는가?”였다. 당시 IT 리서치기업의 조사에 따르면 80% 이상의 자바 엔터프라이즈 프로젝트가 실패했다고 한다. 그 과정에서 밝혀진 여러 가지 원인이 있었지만, 그중 가장 대표적인 게 “엔터프라이즈 시스템 개발이 너무 복잡해져서”였다.복잡함을 해결하려는 도전, 실패한 해결책 EJBEJB는 일부 기술적인 복잡함을 떨어주려는 시도를 하다가 오히려 더 큰 복잡함을 추가하는 실수를 범했다. 가장 치명적인 건, EJB라는 틀 안에서 자바 코드를 만들게강제함으로써 자바 언어가 원래 갖고 있던 장점마저 잃어버렸다는 사실이다.효과적인 해결책 스프링스프링은 EJB 의 실패를 교훈으로 삼아서 출발했다. 스프링 핵심 개발자들은 “스프링의 정수는 엔터프라이즈 서비스 기능을 POJO에 제공히는 것”이라고 했다.스프링은 단지 객체지향 언어의 장점을 제대로 살리지 못하게 방해했던 요소를 제거하도록 도와줄 뿐이다.스프링의 핵심 개념, 컨셉 스프링은 자바 언어 기반의 프레임워크 자바 언어의 가장 큰 특징 - 객체 지향 언어 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크참고 인프런 스프링 핵심원리 - 기본편(김영한) 토비의 스프링" } ]
