<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://liamkim-daeyong.github.io/</id><title>D.Yong Blog</title><subtitle>소프트웨어 장인을 꿈꾸는 백앤드 개발자의 블로그</subtitle> <updated>2022-08-22T14:30:24+09:00</updated> <author> <name>DaeYongKim</name> <uri>https://liamkim-daeyong.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://liamkim-daeyong.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://liamkim-daeyong.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 DaeYongKim </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>즉시로딩과 지연로딩 그리고 프록시</title><link href="https://liamkim-daeyong.github.io/posts/jpa-14/" rel="alternate" type="text/html" title="즉시로딩과 지연로딩 그리고 프록시" /><published>2022-08-22T00:00:00+09:00</published> <updated>2022-08-22T00:00:00+09:00</updated> <id>https://liamkim-daeyong.github.io/posts/jpa-14/</id> <content src="https://liamkim-daeyong.github.io/posts/jpa-14/" /> <author> <name>DaeYongKim</name> </author> <category term="JPA" /> <summary> 회원 엔티티와 팀 엔티티 회원 엔티티와 팀 엔티티가 있다고 가정해보자. 둘은 다음과 같은 관계가 있다. 회원은 하나의 팀에 소속될 수 있다. 하나의 팀은 다수의 회원을 포함하고 있다. 이 경우 회원을 조회한다고 했을 때 팀 엔티티도 함께 조회하는 것이 좋을까? 아니면 회원 엔티티만을 조회하는 것이 좋을까? @Entity @Getter public class Member { @Id private Long memberId; private String memberName; @ManyToOne private Team team; } @Entity @Getter public class Team { @Id private Long teamId; ... </summary> </entry> <entry><title>@MappedSuperclass</title><link href="https://liamkim-daeyong.github.io/posts/jpa-13/" rel="alternate" type="text/html" title="@MappedSuperclass" /><published>2022-08-18T00:00:00+09:00</published> <updated>2022-08-18T00:00:00+09:00</updated> <id>https://liamkim-daeyong.github.io/posts/jpa-13/</id> <content src="https://liamkim-daeyong.github.io/posts/jpa-13/" /> <author> <name>DaeYongKim</name> </author> <category term="JPA" /> <summary> @MappedSupperclass 이전 포스팅에서 상속 관계 매핑에 대해서 알아보았다. 상속관계 매핑은 부모 클래스와 자식 클래스를 모두 데이터베이스 테이블과 매핑하였는데 부모 클래스는 테이블과 매핑하지 않고 부모 클래스를 상속받는 자식 클래스에게 매핑 정보만 제공할 때 사용하는 것이 @MappedSupperclass 이다. 회원(Member)과 판매자(Seller)는 서로 연관이 없는 테이블이다. 하지만 둘은 id, name이라는 공통 속성을 가지고 있다. 그림과 같이 우리는 상속을 통해 이를 표현해보자. @MappedSupperclass public abstract class BaseEntity { @Id @GeneratedValue private Long id; pr... </summary> </entry> <entry><title>상속관계 매핑</title><link href="https://liamkim-daeyong.github.io/posts/jpa-12/" rel="alternate" type="text/html" title="상속관계 매핑" /><published>2022-08-16T00:00:00+09:00</published> <updated>2022-08-16T00:00:00+09:00</updated> <id>https://liamkim-daeyong.github.io/posts/jpa-12/</id> <content src="https://liamkim-daeyong.github.io/posts/jpa-12/" /> <author> <name>DaeYongKim</name> </author> <category term="JPA" /> <summary> 상속관계 매핑 이번 포스팅에서는 상속관계 매핑에 대해서 알아보자. 우선 객체지향 프로그래밍에서 상속이란 객체들 간의 관계를 구축하는 방법으로 객체(서브 클래스)가 다른 객체(슈퍼 클래스)의 속성과 동작을 상속받아 사용하는 것을 말한다. 관계형 데이터베이스에는 이러한 객체지향 언어에서 다루는 상속이라는 개념이 존재하지 않는다. 대신 슈퍼타입 서브타입관계 라는 모델링 기법이 객체의 상속 개념과 가장 유사하다. ORM에서 말하는 상속 관계 매핑은 객체지향의 상속과 데이터베이스의 슈퍼타입 서브타입 관계를 매핑하는 것을 말한다. 슈퍼타입 서브타입 논리 모델을 실제 물리 모델인 테이블로 구현할 수 있는 방법이 3가지가 있는데 JPA는 이러한 3가지 방식을 통해 두 모델(상속, 슈퍼타입 서브타입)을 매핑한... </summary> </entry> <entry><title>양방향 연관관계</title><link href="https://liamkim-daeyong.github.io/posts/jpa-11/" rel="alternate" type="text/html" title="양방향 연관관계" /><published>2022-08-06T00:00:00+09:00</published> <updated>2022-08-06T00:00:00+09:00</updated> <id>https://liamkim-daeyong.github.io/posts/jpa-11/</id> <content src="https://liamkim-daeyong.github.io/posts/jpa-11/" /> <author> <name>DaeYongKim</name> </author> <category term="JPA" /> <summary> 양방향 연관관계 양방향 연관관계는 이전 게시글에서 다룬 단방향 연관관계와 다르게 Member에서 Team으로의 접근 뿐만 아니라 Team에서도 Member에 접근할 수 있는 이름 그대로 양방향에서 매핑이 가능한 것을 말한다. 객체 연관관계를 살펴보면 member는 하나의 team을 가질 수 있다. 반대로 team은 여러 member를 가질 수 있다. 그렇기 때문에 team은 컬렉션으로 member 정보를 가지고 있어야한다. 회원 -&amp;gt; 팀 [ Member.team ] 팀 -&amp;gt; 회원 [ Team.mebmers(List) ] 이제 테이블에서의 관계를 생각해보자. 테이블은 객체와 달리 외래 키 하나로 양방향으로 조회가 가능하다. 객체의 경우는 위와 같이 필드 하나로 양방향 접근이... </summary> </entry> <entry><title>단방향 연관관계</title><link href="https://liamkim-daeyong.github.io/posts/jpa-10/" rel="alternate" type="text/html" title="단방향 연관관계" /><published>2022-08-05T00:00:00+09:00</published> <updated>2022-08-05T14:16:41+09:00</updated> <id>https://liamkim-daeyong.github.io/posts/jpa-10/</id> <content src="https://liamkim-daeyong.github.io/posts/jpa-10/" /> <author> <name>DaeYongKim</name> </author> <category term="JPA" /> <summary> 단방향 연관관계 단방향 연관관계는 1 : N(1대다)인 경우를 말한다. 이 경우는 한 쪽의 엔티티가 관계를 맺은 엔티티 쪽의 여러 객체를 가질 수 있다는 것을 의미한다. 팀은 다수의 회원을 포함하고 있다. 하나의 주문에는 다수의 주문상품이 포함된다. 상위 카테고리는 다수의 하위 카테고리를 가지고 있다. 테이블 연관관계 테이블은 외래 키를 활용하여 연관관계를 맺는다. 그리고 외래 키를 통해서 테이블을 조인할 수 있는데 외래 키가 두 테이블 중 어디에 있든 조인이 가능하다. (양방향 관계) select * from member m join team t on t.team_id = m.team_id select * from team t join member m on m.... </summary> </entry> </feed>
